<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fork系统调用分析]]></title>
    <url>%2F2017%2F09%2F24%2Ffork%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在Linux中，主要是通过fork的方式产生新的进程，我们都知道每个进程都在 内核对应一个PCB块，内核通过对PCB块的操作做到对进程的管理。在Linux内核中，PCB对应着的结构体就是task_struct，也就是所谓的进程描述符（process descriptor）。该数据结构中包含了程相关的所有信息，比如包含众多描述进程属性的字段，以及指向其他与进程相关的结构体的指针。因此，进程描述符内部是比较复杂的。这个结构体的声明位于include/linux/sched.h中。 前言在Linux中，主要是通过fork的方式产生新的进程，我们都知道每个进程都在 内核对应一个PCB块，内核通过对PCB块的操作做到对进程的管理。在Linux内核中，PCB对应着的结构体就是task_struct，也就是所谓的进程描述符（process descriptor）。该数据结构中包含了程相关的所有信息，比如包含众多描述进程属性的字段，以及指向其他与进程相关的结构体的指针。因此，进程描述符内部是比较复杂的。这个结构体的声明位于include/linux/sched.h中。 task_struct中有指向mm_struct结构体的指针mm，也有指向fs_struct结构体的指针fs，这个结构体是对进程当前所在目录的描述；也有指向files_struct结构体的指针files，这个结构体是对该进程已打开的所有文件进行描述。这里我们要注意进程在运行期间中可能处于不同的进程状态，例如：TASK_RUNNING/TASK_STOPPED/TASK_TRACED 等. fork调用在用户态下，使用fork()创建一个进程。除了这个函数，新进程的诞生还可以分别通过vfork()和clone() fork、vfork和clone三个API函数均由glibc库提供，它们分别在C库中封装了与其同名的系统调用fork() 这几个函数调用对应不同场景，有些时候子进程需要拷贝父进程的整个地址空间，但是子进程创建后又立马去执行exec族函数造成效率低下。 写时拷贝满足了这种需求，同时减少了地址空间复制带来的问题。vfork 则是创建的子进程会完全共享父进程的地址空间，甚至是父进程的页表项，父子进程任意一方对任何数据的修改使得另一方都可以感知到。clone函数创建子进程时灵活度比较大，因为它可以通过传递不同的参数来选择性的复制父进程的资源系统调用fork、vfork和clone在内核中对应的服务例程分别为sys_fork()，sys_vfork()和sys_clone()。例如sys_fork()声明如下（arch/x86/kernel/process.c）： 12345678910111213141516int sys_fork(struct pt_regs *regs)&#123; return do_fork(SIGCHLD, regs-&gt;sp, regs, 0, NULL, NULL);&#125;int sys_vfork(struct pt_regs *regs)&#123; return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs-&gt;sp, regs, 0, NULL, NULL);&#125;sys_clone(unsigned long clone_flags, unsigned long newsp, void __user *parent_tid, void __user *child_tid, struct pt_regs *regs)&#123; if (!newsp) newsp = regs-&gt;sp; return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);&#125; 以看到do_fork()均被上述三个服务函数调用。do_fork()正是kernel创建进程的核心（）。通过分析调用过程如下，其中我分析的是最新版4.X Linux源码，在i386体系结构中，采取0x80中断调用syscall： 从图中可以看到do_fork()和copy_process()是本文的主要分析对象。 do_fork函数的主要就是复制原来的进程成为另一个新的进程，在一开始，该函数定义了一个task_struct类型的指针p，用来接收即将为新进程（子进程）所分配的进程描述符。但是这个时候要检查clone_flags是否被跟踪就是ptrace，ptrace是用来标示一个进程是否被另外一个进程所跟踪。所谓跟踪，最常见的例子就是处于调试状态下的进程被debugger进程所跟踪。ptrace字段非0时说明debugger程序正在跟踪父进程，那么接下来通过fork_traceflag函数来检测子进程是否也要被跟踪。如果trace为1，那么就将跟踪标志CLONE_PTRACE加入标志变量clone_flags中。没有的话才可以进程创建，也就是copy_process()。 1234567891011121314151617181920long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls)&#123; struct task_struct *p; int trace = 0; long nr; if (!(clone_flags &amp; CLONE_UNTRACED)) &#123; if (clone_flags &amp; CLONE_VFORK) trace = PTRACE_EVENT_VFORK; else if ((clone_flags &amp; CSIGNAL) != SIGCHLD) trace = PTRACE_EVENT_CLONE; else trace = PTRACE_EVENT_FORK; if (likely(!ptrace_event_enabled(current, trace))) trace = 0; &#125; 这条语句要做的是整个创建过程中最核心的工作：通过copy_process()创建子进程的描述符，并创建子进程执行时所需的其他数据结构，最终则会返回这个创建好的进程描述符。因为copy_process()函数过于巨大，所以另外开辟一篇文章讲解该函数实现。 12p = copy_process(clone_flags, stack_start, stack_size, child_tidptr, NULL, trace, tls); 如果copy_process函数执行成功，那么将继续下面的代码。定义了一个完成量vfork,之后再对vfork完成量进行初始化。如果使用vfork系统调用来创建子进程，那么必然是子进程先执行。原因就是此处vfork完成量所起到的作用：当子进程调用exec函数或退出时就向父进程发出信号。此时，父进程才会被唤醒；否则一直等待。 123456789101112131415if (!IS_ERR(p)) &#123; struct completion vfork; struct pid *pid; trace_sched_process_fork(current, p); pid = get_task_pid(p, PIDTYPE_PID); nr = pid_vnr(pid); if (clone_flags &amp; CLONE_PARENT_SETTID) put_user(nr, parent_tidptr); if (clone_flags &amp; CLONE_VFORK) &#123; p-&gt;vfork_done = &amp;vfork; init_completion(&amp;vfork); get_task_struct(p); &#125; 下面通过wake_up_new_task函数使得父子进程之一优先运行；如果设置了ptrace，那么需要告诉跟踪器。如果CLONE_VFORK标志被设置，则通过wait操作将父进程阻塞，直至子进程调用exec函数或者退出。 123456789101112131415161718wake_up_new_task(p); /* forking complete and child started to run, tell ptracer */if (unlikely(trace)) ptrace_event_pid(trace, pid);if (clone_flags &amp; CLONE_VFORK) &#123; if (!wait_for_vfork_done(p, &amp;vfork)) ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);&#125;put_pid(pid);如果copy_process()在执行的时候发生错误，则先释放已分配的pid；再根据PTR_ERR()的返回值得到错误代码，保存于pid中。 返回pid。这也就是为什么使用fork系统调用时父进程会返回子进程pid的原因。 &#125; else &#123; nr = PTR_ERR(p); &#125; return nr;&#125; 参考： linuxsyscalls abi ds]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别]]></title>
    <url>%2F2017%2F06%2F07%2FOpenSource%2F</url>
    <content type="text"><![CDATA[开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别首先借用有心人士的一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别 以下是上述协议的简单介绍：BSD开源协议BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 Apache Licence 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要再被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。GPL 我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的. MPLMPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: ◆ MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。◆ MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。◆ 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。◆ 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”◆ MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 英文原文：http://www.mozilla.org/MPL/MPL-1.1.html]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 简短学习 just write the code in the PHP way]]></title>
    <url>%2F2017%2F05%2F31%2FlearnLaravel%2F</url>
    <content type="text"><![CDATA[自用笔记：本文属于自用笔记，不做详解，仅供参考。 artisan123英 /,ɑːtɪ&apos;zæn; &apos;ɑːtɪzæn/美 /&apos;ɑrtəzn/n. 工匠，技工 介绍 Artisan 是 Laravel 的命令行接口的名称，它提供了许多实用的命令来帮助你开发 Laravel 应用，它由强大的 Symfony Console 组件所驱动。 可以使用 list 命令来列出所有可用的 Artisan 命令： 1php artisan list Available commands: 命令 explain 说明 clear-compiled Remove the compiled class file 清除编译后的类文件 down Put the application into maintenance mode 使应用程序进入维修模式 env Display the current framework environment 显示当前框架环境 help Displays help for a command 显示命令行的帮助 list Lists commands 列出命令 migrate Run the database migrations 运行数据库迁移 optimize Optimize the framework for better performance 为了更好的框架去优化性能 serve Serve the application on the PHP development server 在php开发服务器中服务这个应用 tinker Interact with your application 在你的应用中交互 up Bring the application out of maintenance mode 退出应用程序的维护模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859app app:name Set the application namespace 设置应用程序命名空间auth auth:clear-resets Flush expired password reset tokens 清除过期的密码重置密钥cache cache:clear Flush the application cache 清除应用程序缓存 cache:table Create a migration for the cache database table 创建一个缓存数据库表的迁移config config:cache Create a cache file for faster configuration loading 创建一个加载配置的缓存文件 config:clear Remove the configuration cache file 删除配置的缓存文件db db:seed Seed the database with records 发送数据库的详细记录event event:generate Generate the missing events and listeners based on registration 在记录上生成错过的事件和基础程序key key:generate Set the application key 设置程序密钥make make:auth Scaffold basic login and registration views and routes make:console Create a new Artisan command 生成一个Artisan命令 make:controller Create a new controller class 生成一个资源控制类 make:event Create a new event class 生成一个事件类 make:job Create a new job class make:listener Create a new event listener class make:middleware Create a new middleware class 生成一个中间件 make:migration Create a new migration file 生成一个迁移文件 make:model Create a new Eloquent model class 生成一个Eloquent 模型类 make:policy Create a new policy class make:provider Create a new service provider class 生成一个服务提供商的类 make:request Create a new form request class 生成一个表单消息类 make:seeder Create a new seeder class make:test Create a new test classmigrate migrate:install Create the migration repository 创建一个迁移库文件 migrate:refresh Reset and re-run all migrations 复位并重新运行所有的迁移 migrate:reset Rollback all database migrations 回滚全部数据库迁移 migrate:rollback Rollback the last database migration 回滚最后一个数据库迁移 migrate:status Show the status of each migration 显示列表的迁移 上/下queue queue:failed List all of the failed queue jobs 列出全部失败的队列工作 queue:failed-table Create a migration for the failed queue jobs database table 创建一个迁移的失败的队列数据库工作表 queue:flush Flush all of the failed queue jobs 清除全部失败的队列工作 queue:forget Delete a failed queue job 删除一个失败的队列工作 queue:listen Listen to a given queue 监听一个确定的队列工作 queue:restart Restart queue worker daemons after their current job 重启现在正在运行的所有队列工作 queue:retry Retry a failed queue job 重试一个失败的队列工作 queue:table Create a migration for the queue jobs database table 创建一个迁移的队列数据库工作表 queue:work Process the next job on a queue 进行下一个队列任务route route:cache Create a route cache file for faster route registration 为了更快的路由登记，创建一个路由缓存文件 route:clear Remove the route cache file 清除路由缓存文件 route:list List all registered routes 列出全部的注册路由schedule schedule:run Run the scheduled commands 运行预定命令session session:table Create a migration for the session database table 创建一个迁移的SESSION数据库工作表vendor vendor:publish Publish any publishable assets from vendor packages 发表一些可以发布的有用的资源来自提供商的插件包view view:clear Clear all compiled view files 每个命令也包含了「帮助」界面，它会显示并概述命令可使的参数及选项。只要在命令前面加上 help 即可显示帮助界面： 1php artisan help migrate 1php artisan make:auth 编写命令 除了使用 Artisan 本身所提供的命令之外，Laravel 也允许你自定义 Artisan 命令。 自定义命令默认存储在 app/Console/Commands 目录中，当然，只要在 composer.json 文件中的配置了自动加载，你可以自由选择想要放置的地方。 若要创建新的命令，你可以使用 make:console Artisan命令生成命令文件： 1php artisan make:console SendEmails 上面的这个命令会生成 app/Console/Commands/SendEmails.php 类，–command 参数可以用来指定调用名称： 1php artisan make:console SendEmails --command=emails:send 命令结构 一旦生成这个命令，应先填写类的 signature 和 description 这两个属性，它们会被显示在 list 界面中。命令运行时 handle 方法会被调用，请将程序逻辑放置在此方法中。接下来讲解一个发送邮件的例子。为了更好的代码重用性，还有可读性，建议把处理业务逻辑的代码抽到一个功能类里。Command 类构造器允许注入需要的依赖，Laravel 的 服务容器 将会自动把功能类 DripEmailer 解析到构造器中 Route 你可以在 app/Http/routes.php 文件中定义应用程序的大多数路由，该文件将会被 App\Providers\RouteServiceProvider 类加载。最基本的 Laravel 路由仅接受 URI 和一个闭包 view-Blade Blade 是 Laravel 所提供的一个简单且强大的模板引擎。相较于其它知名的 PHP 模板引擎，Blade 并不会限制你必须得在视图中使用 PHP 代码。所有 Blade 视图都会被编译缓存成普通的 PHP 代码，一直到它们被更改为止。这代表 Blade 基本不会对你的应用程序生成负担。 Blade 视图文件使用 .blade.php 做为扩展名，通常保存于 resources/views 文件夹内。 @extends(&#39;layouts.app&#39;) 这表示此视图的基视图是 resources/views/layouts/app.blade.php 。这个函数还隐含了一个小知识：在使用名称查找视图的时候，可以使用 . 来代替 / 或 \. @Section(&#39;content&#39;) ... @endsection这两个标识符之前的代码，会被放到基视图的 @yield(&#39;content&#39;) 中进行输出。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>phper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Guzzle刷豆瓣热评引发的联想]]></title>
    <url>%2F2017%2F04%2F12%2FGuzzle%2F</url>
    <content type="text"><![CDATA[Guzzle是一个PHP的HTTP客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。 接口简单：构建查询语句、POST请求、分流上传下载大文件、使用HTTP cookies、上传JSON数据等等 。 发送同步或异步的请求均使用相同的接口。 使用PSR-7接口来请求、响应、分流，允许你使用其他兼容的PSR-7类库与Guzzle共同开发。 抽象了底层的HTTP传输，允许你改变环境以及其他的代码，如：对cURL与PHP的流或socket并非重度依赖，非阻塞事件循环。 中间件系统允许你创建构成客户端行为。 所需包123&quot;require&quot;: &#123; &quot;guzzlehttp/guzzle&quot;: &quot;6.2.*&quot;&#125; 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phpinclude_once dirname(__FILE__).&apos;/vendor/autoload.php&apos;;use \GuzzleHttp\Client;use \GuzzleHttp\Cookie\CookieJar;use \GuzzleHttp\Exception\RequestException;/** * 豆瓣租房刷留言 */class DouBanBrush&#123; public $jar; public $clock = 10; const SLEEP = 1200; // 睡20 分钟 /** * [__autoload 初始化] * @author Shaowei Pu &lt;542684913@qq.com&gt; * @CreateTime 2017-04-12T10:39:28+0800 * @param [type] $account [description] * @param [type] $password [description] * @return [type] [description] */ public function __construct( $account, $password )&#123; $this-&gt;jar = new CookieJar; try&#123; if( $this-&gt;login( $account, $password ) == &apos;200&apos;)&#123; echo &quot;----------【 START 】----------\n&quot;; $this-&gt;send(); echo &quot;----------【 END 】----------\n&quot;; &#125;else&#123; echo &quot;登录失败～！&quot;; &#125; &#125;catch (RequestException $e) &#123; var_dump( $e-&gt;getRequest()); if ($e-&gt;hasResponse()) &#123; var_dump( $e-&gt;getResponse()); &#125; &#125; &#125; /** * [login 登录] * @author Shaowei Pu &lt;542684913&gt; * @CreateTime 2017-04-12T10:42:16+0800 * @return [type] [description] */ public function login( $account , $password )&#123; // 清楚空间内cookie // $this-&gt;jar-&gt;clear(); return ( new Client([ &apos;cookies&apos; =&gt; true ]) )-&gt;request( &apos;POST&apos;, &apos;https://accounts.douban.com/j/popup/login/basic&apos;, [ &apos;version&apos; =&gt; 1.1 , &apos;cookies&apos; =&gt; $this-&gt;jar, &apos;headers&apos; =&gt; [ &apos;Accept&apos; =&gt; &apos;application/json&apos;, &apos;Referer&apos; =&gt; &apos;登录来源页&apos; ], &apos;form_params&apos; =&gt; [ &apos;source&apos; =&gt; &apos;group&apos;, &apos;referer&apos; =&gt; &apos;提交接口&apos;, &apos;name&apos; =&gt; $account, &apos;password&apos; =&gt; $password, &apos;captcha_id&apos; =&gt; &apos;&apos;, &apos;captcha_solution&apos; =&gt; &apos;&apos; ] ])-&gt;getStatusCode(); &#125; /** * [send 发送内容] * @author Shaowei Pu &lt;542684913@qq.com&gt; * @CreateTime 2017-04-12T10:43:17+0800 * @return [type] [description] */ public function send() &#123; // 获得 ck $this-&gt;reload(); $ck = &apos;ntxB&apos;; array_map(function( $val ) use (&amp; $ck )&#123; $val[&apos;Name&apos;] == &apos;ck&apos; &amp;&amp; $ck = $val[&apos;Value&apos;]; &#125;, $this-&gt;jar-&gt;toArray()); // 计时器 while ( $this-&gt;clock &gt; 0 ) &#123; $send_content = ( new Client([ &apos;cookies&apos; =&gt; true ]) )-&gt;request( &apos;POST&apos;, &apos;提交接口&apos;, [ &apos;version&apos; =&gt; 1.1, &apos;cookies&apos; =&gt; $this-&gt;jar, &apos;headers&apos; =&gt; [ &apos;Accept&apos; =&gt; &apos;application/json&apos;, &apos;Referer&apos; =&gt; &apos;来源页&apos; ], &apos;form_params&apos; =&gt; [ &apos;ck&apos; =&gt; $ck, &apos;rv_comment&apos; =&gt; &apos;自己顶一下～！&apos;, &apos;start&apos; =&gt; 0, &apos;submit_btn&apos; =&gt;&apos;加上去&apos; ] ])-&gt;getBody()-&gt;getContents(); echo date(&apos;Y-m-d H:i:s&apos;).&apos; &apos;.$this-&gt;clock.&quot;\n&quot;; sleep( self::SLEEP ); --$this-&gt;clock; &#125; &#125; /** * [reload 刷新页面] * @author Shaowei Pu &lt;542684913@qq.com&gt; * @CreateTime 2017-04-12T13:35:58+0800 * @return [type] [description] */ public function reload()&#123; (new Client([ &apos;cookies&apos; =&gt; true ])) -&gt;request(&apos;GET&apos;, &apos;访问页&apos;,[ &apos;cookies&apos; =&gt; $this-&gt;jar, &apos;headers&apos; =&gt; [ &apos;Accept&apos; =&gt; &apos;application/json&apos;, &apos;Referer&apos; =&gt; &apos;来源页&apos; ]]); &#125;&#125;new DouBanBrush(&apos;账号&apos;,&apos;密码&apos;); 还没做的事 验证码识别 优化效率 致敬像 @娃娃脾气 大佬致敬]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[But you should have one thing mind.]]></title>
    <url>%2F2017%2F03%2F10%2Feveryday%2F</url>
    <content type="text"><![CDATA[随时更新一下值得记忆的一些踏过的坑 Mac git 大小写问题由于 Mac 下文件名大小写不敏感，造成 git 下如果改了名字，譬如小写改大些，推送到 linux 服务器的时候会没有效果，Github 上的也是小写。所以，如果在 Mac 上改文件名，需要用下面的命令 1234$ git mv --force myfile MyFile#修改git配置，不忽略大小写git config core.ignorecase false 删除git 远程的分支1$ git push --delete origin branch_name 推送出现一些同步的错误，可以加个-f1$ git push origin dev -f 修改crontab 的编辑器1export EDITOR=/usr/bin/vim # crontab -e redis MONITOR 监控redis的所有的被执行的命令123456789101112131415161718192021//在程序之外用管道监控某一个命令。redis-cli -h 172.16.71.70 -p 6379 MONITOR|grep medal:rank:91472647383.968024 [0 172.16.71.67:48460] "ZINCRBY" "medal:rank:9" "1.0000000000000000" "12436136"1472647384.560867 [0 172.16.71.69:60301] "ZADD" "medal:rank:9" "108.0000000000000000" "12436136"1472647384.561215 [0 172.16.71.69:60301] "ZCARD" "medal:rank:9"1472647440.527100 [0 172.16.71.67:48566] "ZINCRBY" "medal:rank:9" "1.0000000000000000" "12436136"1472647440.811201 [0 172.16.71.69:60301] "ZADD" "medal:rank:9" "109.0000000000000000" "12436136"1472647440.811598 [0 172.16.71.69:60301] "ZCARD" "medal:rank:9"1472647456.269238 [0 172.16.71.67:48586] "ZINCRBY" "medal:rank:9" "1.0000000000000000" "12436136"1472647457.091923 [0 172.16.71.69:60301] "ZADD" "medal:rank:9" "110.0000000000000000" "12436136"1472647457.092253 [0 172.16.71.69:60301] "ZCARD" "medal:rank:9"1472647457.523799 [0 172.16.71.67:48593] "ZINCRBY" "medal:rank:9" "1.0000000000000000" "12436136"1472647458.364086 [0 172.16.71.69:60301] "ZADD" "medal:rank:9" "111.0000000000000000" "12436136"1472647458.364470 [0 172.16.71.69:60301] "ZCARD" "medal:rank:9"1472647473.428126 [0 172.16.71.67:48605] "ZCARD" "medal:rank:9"1472647473.451694 [0 172.16.71.67:48605] "ZCARD" "medal:rank:9"1472647473.451863 [0 172.16.71.67:48605] "ZREVRANK" "medal:rank:9" "12436136"1472647473.452154 [0 172.16.71.67:48605] "ZREVRANGE" "medal:rank:9" "0" "9"1472647516.470815 [0 172.16.71.67:48690] "ZINCRBY" "medal:rank:9" "1.0000000000000000" "12436136"1472647516.663979 [0 172.16.71.69:60301] "ZADD" "medal:rank:9" "112.0000000000000000" "12436136"1472647516.664325 [0 172.16.71.69:60301] "ZCARD" "medal:rank:9" 监控文件的实时数据 tail -f12345678910//当文件有数据写入时，能实时的输出tail -f app.loglogs tail -f app.log[2016-08-25 18:57:37] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;9aeff67&quot;&#125;[2016-08-25 18:57:37] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;a117fed&quot;&#125;[2016-08-25 18:57:42] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;c6edb36&quot;&#125;[2016-08-25 18:57:42] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;a29a035&quot;&#125;[2016-08-25 19:02:00] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;a11dfb4&quot;&#125;[2016-08-25 19:02:59] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;95e2320&quot;&#125;[2016-08-25 19:03:07] slim-app.INFO: Slim-Skeleton &apos;/&apos; route [] &#123;&quot;uid&quot;:&quot;3a5aa35&quot;&#125; set_error_handler PHP中用来捕获自定义的错误信息1234567891011121314public function aaa()&#123; function customError($errno, $errstr, $errfile, $errline) &#123; echo "&lt;b&gt;Custom error:&lt;/b&gt; [$errno] $errstr&lt;br /&gt;"; echo " Error on line $errline in $errfile&lt;br /&gt;"; echo "Ending Script"; die(); &#125; //set error handler， 第二个参数是可以设置需要捕获的错误类型 set_error_handler("customError", E_ALL | E_WARNING); //$a 没定义，应该会有一个错误： var_dump($a);&#125; 看下打印输出，就能按照我们的方式输出打印错误： 1&lt;b&gt;Custom error:&lt;/b&gt; [8] Undefined variable: a&lt;br /&gt; Error on line 169 in /data/app/live/include/controller/TmpCtrl.php&lt;br /&gt;Ending Script% php cli 命令1234567891011121314151617181920212223242526272829php -i查看phpinfophp -v显示PHP版本php -m查看PHP安装了哪些扩展模块，可修改php.ini添加删除扩展模块。编译PHP时内置的扩展，无法通过修改php.ini删除php -S启动一个内置的Web服务器，用于开发环境内进行程序的调试。php -S 0.0.0.0:9000内置的Web服务器是一个全功能的Http服务器，在开发模式下可以取代apache,nginx+php-fpm，但不可用于线上生产环境。可以使用-t参数指定document_root，如果不指定表示使用当前目录作为document_rootphp -S 0.0.0.0:9000 -t /data/webroot/php -c指定加载php.ini的绝对路径php -c /home/htf/my_php.iniphp -l检测一个php代码文件是否有语法错误，如 php -l test.phpphp -r执行一段php代码，如php -r "echo 'hello world';"php --ini显示当前加载的php.ini绝对路径php --re swoole显示某个扩展提供了哪些类和函数。php --ri swoole显示扩展的phpinfo信息。与phpinfo的作用相同，不同之处是这里仅显示指定扩展的phpinfophp --rf file_get_contents显示某个PHP函数的信息，一般用于检测函数是否存在 Linux下查看一个端口被哪个占用进程12345netstat -apn|grep 7782tcp 0 0 :::80 :::* LISTEN 19408/java #那么进程号就是`19408`再通过`ps -ef | grep 19408` 就知道这个进程是啥了。+]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>phper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Decorator 装饰器模式]]></title>
    <url>%2F2017%2F02%2F23%2FDecorator%2F</url>
    <content type="text"><![CDATA[如果已有对象的部分内容或功能性发生改变，但是不需要修改原始的结构 迭代新的应用需求 12345678910111213141516171819202122232425262728/** * Decorator 装饰器模式 * ------------------------------------- * ** 来自说明 ** * * 如果已有对象的部分内容或功能性发生改变，但是不需要修改原始的结构 * * 刚开始楼主觉得这个他么怎么这么像 【 适配器模式 】 * 然后又把适配器模式的理论复制了过来给各位观众老爷看 * * |-&gt; 适配器模式： * 通过适配器模式能够使用新的代码和功能性来帮助更新原有的系统。 * * 前面演练过了，适配器还是需要继承原对象来实现，但是我们最开始学习面向对象编程时候 * 如果对象开始要求启用过多的子类，那么相应的代码就会牺牲编程人员的理解力和可维护性 * 通常，我们会竭力保证用于一个对象的父-子类关系不超过3个 * * * ===================================== * ** 应用场景 ** * * 迭代新的应用需求 * * ------------------------------------- * * @version $&#123;Id&#125;$ * @author Shaowei Pu &lt;54268491@qq.com&gt; */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;?php// 现在你是一个农场饲养员，主要负责养猪方面工作/** * 饲养类 */class feeding&#123; /** * [$mess_tin 饭盒] * @var array */ public $mess_tin = []; /** * [feed 喂食物] * @author Shaowei Pu &lt;pushaowei@sporte.cn&gt; * @CreateTime 2017-02-23T19:47:18+0800 * @param [type] $food [description] * @return [type] [description] */ public function feed( $food )&#123; $this-&gt;mess_tin[] = $food; &#125; /** * [getHow 吃了哪些东西] * @author Shaowei Pu &lt;pushaowei@sporte.cn&gt; * @CreateTime 2017-02-23T19:51:41+0800 * @return [type] [description] */ public function getHow()&#123; return $this-&gt;mess_tin; &#125;&#125;// 以前你通过这样的方式可以喂猪$you = new feeding;// 然后老板给了这些食物$bread = [ 'apple', 'tangerine', 'banana', ];foreach ($bread as $key =&gt; $value) &#123; $you-&gt;feed($value);&#125;// 看看吃了些啥var_dump( $you-&gt;getHow() );/* +----------------------------------------------------------------------|array (size=3)| 0 =&gt; string 'apple' (length=5)| 1 =&gt; string 'tangerine' (length=9)| 2 =&gt; string 'banana' (length=6)+----------------------------------------------------------------------*/// 但是有天高级饲养说这喂的这些食物都是小写的 这不行，给猪必须要大写的// 然后你看了下饲养类，听隔壁兄弟这个类不仅仅用在猪身上// 也有养羊事业部，羊牛事业部，同样用的这个类// 你不能瞎几把乱改// 学了适配器的你马上想到了 使用【适配器模式】可以解决问题// 但是立马老大就说了不准乱继承。一个父类最多继承 3 个子类// 于是聪明的你想到了这样一个方法/** * 养猪事业部专用 */class feddingDecorator&#123; /** * [$_feeding 基类容器] * @var array */ private $_feeding = []; /** * [__construct 基类入变量] * @author Shaowei Pu &lt;pushaowei@sporte.cn&gt; * @CreateTime 2017-02-23T20:00:58+0800 * @param feeding $feeding [description] */ public function __construct( feeding $feeding ) &#123; $this-&gt;_feeding = $feeding; &#125; /** * [expertFeed 高级食物转换器] * @author Shaowei Pu &lt;pushaowei@sporte.cn&gt; * @CreateTime 2017-02-23T20:04:42+0800 * @return [type] [description] */ public function expertFeed() &#123; array_walk($this-&gt;_feeding-&gt;mess_tin, function( &amp;$value )&#123; $value = strtoupper( $value ); &#125;); &#125;&#125;// 然后这样,前期您还是放心喂$me = new feeding;foreach ($bread as $key =&gt; $value) &#123; $me-&gt;feed($value);&#125;// 然后你喂完了就开始用的养猪专业部使用的高科技了$stm = new feddingDecorator( $me );$stm-&gt;expertFeed();// 看看吃了啥var_dump($me-&gt; getHow());/* +----------------------------------------------------------------------|array (size=3)| 0 =&gt; string 'APPLE' (length=5)| 1 =&gt; string 'TANGERINE' (length=9)| 2 =&gt; string 'BANANA' (length=6)+----------------------------------------------------------------------*/// 掌声经久不息]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Builder 建造者模式]]></title>
    <url>%2F2017%2F02%2F22%2FBuilder%2F</url>
    <content type="text"><![CDATA[建造者设计模式的母的是消除其他对象的复杂创建过程 使用建造者设计模式不仅是最佳的做法，而且在某个对象的构造和配置方法改变时尽可能地减少重复的代码 12345678910111213141516171819/** * Builder 建造者模式 * ------------------------------------- * ** 来自说明 ** * * 建造者设计模式的母的是消除其他对象的复杂创建过程， * 使用建造者设计模式不仅是最佳的做法 * 而且在某个对象的构造和配置方法改变时尽可能地减少重复的代码 * * ===================================== * ** 应用场景 ** * * 数据库接口类 | 优化基类 * * ------------------------------------- * * @version $&#123;Id&#125;$ * @author Shaowei Pu &lt;54268491@qq.com&gt; */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php// 现在是这样一个情况，您是学生个人档案录入员，你写了这样一个类class Entering &#123; public $info = []; public function setName( $name )&#123; $this-&gt;info['name'] = $name; &#125; public function setOld( $old )&#123; $this-&gt;info['old'] = $old; &#125; public function setGender( $gender )&#123; $this-&gt;info['gander'] = $gender; &#125;&#125;// 然后你看到了你们Boss 在许多年前，你还是一个乳臭未干的小孩时写的录入类 $worker = new Entering;$worker-&gt;setName('jacky');$worker-&gt;setOld('22');$worker-&gt;setGender('男');// 然后这样就可以了,一个学生的完整信息就这么弄出来了var_dump($worker-&gt;info);/* +----------------------------------------------------------------------| array (size=3)| 'name' =&gt; string 'jacky' (length=5)| 'old' =&gt; string '22' (length=2)| 'gander' =&gt; string '男' (length=3)+----------------------------------------------------------------------*/// 但是爱折腾的你从来不会放弃任何机会，自从学习了建造者模式的你 总有种蠢蠢欲动，于是乎就有了下面的类class EnteringBuilder&#123; protected $_baseObject = null; protected $_newInfo = [] ; public function __construct( array $info )&#123; $this-&gt;_baseObject = new Entering; $this-&gt;_newInfo = $info; &#125; public function build()&#123; $this-&gt;_baseObject-&gt;setName ( $this-&gt;_newInfo['name']); $this-&gt;_baseObject-&gt;setOld ( $this-&gt;_newInfo['old']); $this-&gt;_baseObject-&gt;setGender( $this-&gt;_newInfo['gander']); &#125; public function getInfo()&#123; return $this-&gt;_baseObject-&gt;info; &#125;&#125;// 然后这样$new_worker = new EnteringBuilder([ 'name' =&gt; 'lucy', 'old' =&gt; 22, 'gander' =&gt; '女', ]);$new_worker-&gt;build();// 然后这样就可以了,一个学生的完整信息就这么弄出来了var_dump($new_worker-&gt;getInfo());/* +----------------------------------------------------------------------|array (size=3)| 'name' =&gt; string 'lucy' (length=4)| 'old' =&gt; int 22| 'gander' =&gt; string '女' (length=3)+----------------------------------------------------------------------*/]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 适配器模式(Adapter Design Pattern)]]></title>
    <url>%2F2017%2F02%2F21%2FphpAdapter%2F</url>
    <content type="text"><![CDATA[适配器设计模式知识将某个对象的借口是配为另一个对象所期望的接口 通过适配器模式能够使用新的代码和功能性来帮助更新原有的系统，简单的说需要转化一个对象的接口用于另一个对象中时，在不改变原对象的基础上可以采用适配器模式 12345678910111213141516171819/** * Adapter 适配器模式 * ------------------------------------- * ** 来自说明 ** * * 通过适配器模式能够使用新的代码和功能性来帮助更新原有的系统。 * 简单的说需要转化一个对象的接口用于另一个对象中时， * 在不改变原对象的基础上可以采用适配器模式 * * ===================================== * ** 应用场景 ** * * 对于项目中比较旧的架构底层的基类做接口更改时使用 * * ------------------------------------- * * @version $&#123;Id&#125;$ * @author Shaowei Pu &lt;542684913@QQ.com&gt; */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php// 你现在是大巍施工队分配到伊朗的挖矿工头。/** * 大巍施工队总部 */class headquarters &#123; protected $_worker; public function __construct($worker)&#123; $this-&gt;_worker = $worker; &#125; public function getWorker()&#123; if( !empty($this-&gt;_worker) )&#123; return '力大无穷'.$this-&gt;_worker.'个挖矿师傅'; &#125; &#125;&#125;/** * 分包出去干活的 */class assignWorker&#123; protected $_workerObject; public function __construct(headquarters $_workerObject )&#123; $this-&gt;_workerObject = $_workerObject; &#125; public function assign()&#123; echo $this-&gt;_workerObject-&gt;getWorker(); // 将错误信息输出至控制台 &#125;&#125;/** * 现在你要20个力大无穷的搬砖师傅，然后找下总部，总部就给你了 */$Iran = new assignWorker(new headquarters(20));$Iran-&gt;assign();echo "&lt;hr/&gt;";// 日复一日，年复一年，你又被调到黎巴嫩挖矿，这边不同于你在伊朗的日子了，这里你要挖取钻石矿// 但是这个钻石矿要几个砖家配合挖矿师傅才行，可是公司现在不能提供给你其他部门，因为咱们是百年大企业，主单位不能随便加部门进去// 大巍国际的人才培养很利索，要什么有什么，这可难不倒你。所以你想了这样一个办法// /** * 黎巴嫩专用适配器 */class Adapter extends headquarters&#123; public function __construct($worker)&#123; parent::__construct($worker); $this-&gt;getallheaders(); &#125; public function getallheaders()&#123; $this-&gt;_worker ='勇敢过人的'.($this-&gt;_worker/2).'个砖家在加上'.$this-&gt;_worker; &#125;&#125;// 这下你要的的人就出来了$Lebanon = new assignWorker(new Adapter(20));$Lebanon-&gt;assign();]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 之隐藏你的代码]]></title>
    <url>%2F2017%2F02%2F20%2Fhiderjs%2F</url>
    <content type="text"><![CDATA[1Function("‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‌‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‌‍‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‌‍‌‍‍‌‍‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‌‍‍‌‌‌‌‍‌‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‌‍‌‌‌‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‌‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‍‍‍‍‌‍‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‌‌‍‍‍‌‍‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‍‌‍‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‌‍‌‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‌‍‍‌‌‌‌‍‌‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‌‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‍‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‌‌‍‌‌‍‍‌‍‍‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‌‌‌‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‍‌‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‌‌‌‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‍‌‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‌‌‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‍‌‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‍‌‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‌‍‌‍‌‍‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‌‍‌‌‌‌‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‌‍‌‌‌‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‌‍‌‌‌‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‌‍‍‍‌‌‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‌‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‌‌‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‌‍‌‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‌‍‌‌‌‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‌‍‌‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‍‍‌‌‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‍‍‍‍‌‌‍‌‌‍‌‌‌‌‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‌‍‌‌‍‌‌‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‌‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‌‌‌‌‌‍‍‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‌‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‌‌‌‍‌‍‌‌‍‌‌‍‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‌‍‌‌‌‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‌‌‌‍‍‍‌‌‍‌‍‌‍‍‍‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‌‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‌‍‍‍‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‌‍‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‌‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‍‌‌‌‍‌‌‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‌‍‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‌‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‍‍‌‍‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‌‍‍‍‍‍‌‌‍‌‌‌‍‍‌‌‍‍‌‍‍‍‌‌‍‌‍‌‍‍‌‌‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‍‌‌‍‌‌‍‌‌‍‌‍‌‌‍‍‌‍‌‍‌‌‍‍‌‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‌‍‌‌‍‍‍‍‌‌‍‍‌‍‍‍‌‌‍‍‍‌‍‍‌‍‌‌‍‍‍‍‌‍‌‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‍‍‍‌‌‌‍‍‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‌‍‍‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‌‌‌‍‌‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‌‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‍‍‍‍‍‌‍‌‌‌‍‍‌‍‍‌‌‌‍‍‌‍‍‌‌‍‍‍‍‌‍‌‌‌‌‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‌‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‌‌‍‍‍‌‌‌‌‌‌‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‌‌‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‍‌‌‍‍‌‌‌‌‌‌‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‍‌‌‌‌‍‍‌‌‍‍‍‌‌‍‌‍‌‌‌‌‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‍‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‌‍‌‌‌‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‌‌‌‌‌‍‍‍‌‌‌‌‌‌‍‍‌‌‍‍‌‍‍‍‍‌‍‌‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‌‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‌‌‍‍‌‌‍‍‍‍‌‍‌‌‌‍‍‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‍‌‌‌‌‍‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‌‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‍‌‍‌‌‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‌‍‍‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‍‌‌‍‍‍‌‍‍‌‌‍‌‌‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‍‍‌‌‍‍‍‌‌‍‌‌‍‍‍‌‌‍‌‍‌‍‍‌‌‍‌‍‌‍‍‌‌‍‍‌‌‍‍‌‌‍‌‍‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‍‍‌‌‍‍‌‌‌‍‌‍‌‍‌‌‍‌‌‌‍‍‌‌‍‍‍‌‌‍‌‌‌‍‌‍‍‍‌‌‍‌‍‍‌‍‌‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‌‍‍‍‌‍‌‍‍‍‍‌‌‍‍‍‍‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‌‍‍‍‌‍‌‍‍‌‍‌‌‌‌‍‌‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‍‍‍‍‌‌‌‌‍‍‍‌‌‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‍‍‍‍‌‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‌‌‌‍‍‍‌‌‍‍‌‌‍‍‌‌‍‍‌‍‍‍‌‍‌‌‍‌‍‌‌‍‍‍‌‍‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‍‌‍‌‍‌‌‌‍‌‍‍‍‌‌‌‍‌‍‌‍‌‌‌‍‍‌‍‍‌‌‍‌‌‌‍‍‍‌‍‍‍‍‍‍‌‌‍‌‍‍‌‍‍‌‌‌‌‍‌‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‍‍‍‌‍‌‌‍‍‍‌‌‍‌‍‌‌‍‍‌‌‌‍‌‌‍‌‌‌‌‌‍‌‍‍‌‍‌‍‍‍‍‍‌‍‌‍‍‌‍‍‌‌‌‍‌‌".replace(/.&#123;8&#125;/g,function(u) &#123;return String.fromCharCode(parseInt(u. replace(/\u200c/g,1).replace(/\u200d/g, 0),2))&#125;))(); 标题里的“短”字加了引号，只是因为它看起来短，实际并不短，因为字节还是在的，在 unicode 里有一种神奇的字符叫 零宽空白，它的特点是字型的显示宽度为 0，无论堆了多少个零宽字符，你都看不见它。 就像上面我写的例子中，Function(&quot;&lt;这里&gt;&quot;.repla... 藏了大量的零宽字符，实际看起来就好像是一个空字符串 “”，这个“空”字串即是 md5 的函数定义经过编码转换后得到的全零宽字符串，此创意最初源自一个叫z.js 的库。 每个字符都有一个唯一的编码，将编码以 2 进制表示得到 01.. 的字串，把 1 替换成 U+200C，把 0 替换成 U+200D 就得到一个全零宽空白的字符串，每 8 位零宽字符可用于表示 1 个 ascii字符，所以例子当中，理论上是变长的，不算解码程序的 129 个字符，仅空白就占了原文 8 倍的体积，如果出现中文，那就更不止了，因为中文已经超过了 ascii 的范围，需要先转成纯 ascii （如以 \uxxxx 表示）后再处理。 在 unicode 里，至少有 U+200B, U+200C, U+200D 和 U+FEFF 四个零宽字符，如果把这 4 个字符全用上，上面的例子又可以减少 1 半的体积 1234567891011121314151617181920212223242526272829303132333435363738function(window) &#123; var rep = &#123; // 替换用的数据，使用了4个零宽字符，数据量减少了一半。 '00': '\u200b', '01': '\u200c', '10': '\u200d', '11': '\uFEFF' &#125;; function hide(str) &#123; str = str.replace(/[^\x00-\xff]/g, function(a) &#123; // 转码 Latin-1 编码以外的字符。 return escape(a).replace('%', '\\'); &#125;); str = str.replace(/[\s\S]/g, function(a) &#123; // 处理二进制数据并且进行数据替换 a = a.charCodeAt().toString(2); a = a.length &lt; 8 ? Array(9 - a.length).join('0') + a : a; return a.replace(/../g, function(a) &#123; return rep[a]; &#125;); &#125;); return str; &#125; var tpl = '("@code".replace(/.&#123;4&#125;/g,function(a)&#123;var rep=&#123;"\u200b":"00","\u200c":"01","\u200d":"10","\uFEFF":"11"&#125;;return String.fromCharCode(parseInt(a.replace(/./g, function(a) &#123;return rep[a]&#125;),2))&#125;))'; window.hider = function(code, type) &#123; var str = hide(code); // 生成零宽字符串 str = tpl.replace('@code', str); // 生成模版 if (type === 'eval') &#123; str = 'eval' + str; &#125; else &#123; str = 'Function' + str + '()'; &#125; return str; &#125;&#125;)(window); 来测试下效果。(点代码框右上角运行即可) 12var code = hider('alert("测试一下。。")');console.log(code);]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 学习第二章 Event Io 与 process]]></title>
    <url>%2F2016%2F09%2F11%2Fswoole_2%2F</url>
    <content type="text"><![CDATA[介绍异步非阻塞io、进程的相关知识 介绍Event Loop 异步io的使用、常见问题和解决方案和实例 介绍Process 如何使用对象，Process通信使用实例 装逼环节 介绍异步非阻塞io、进程的相关知识 介绍Event Loop 异步io的使用、常见问题和解决方案和实例 介绍Process 如何使用对象，Process通信使用实例 装逼环节 进程刚刚才说了，子进程当复制一个父进程的时候会复制它的内存以及它的上下文环境，除了这些之外，子进程会复制父进程的io句柄(fd描述符) [x] 子进程会复制父进程的IO句柄(我们打开的一个文件，以及创建的一个socked连接，这些都属于句柄，比如我在父进程内打开了一个文件fopen拥有一个fd描述符。那么子进程中同样拥有这个句柄，并且可以对同一个文件进行读写操作，这样的话多个进程对一个文件进行读写操作的话就会对文件造成混乱，这个时候我们就需要一个文件锁的东西，fd描述符); 进程之间的通信方式 – 管道 我们在父进程创建一个管道的时候，这个管道会创建一组，就是两个描述符，一个描述符用来读一个描述符用来写，当父进程创建了一个管道的时候，那么它相对应的子进程也拥有相同的两个描述符。 父进程通过对描述符当中写内容的时候子进程就可以通过读描述符来得到管道中的内容这样就实现了两个进程之间的通信， [x] 管道是一组（2个）特殊的描述符 [x] 管道需要在fork函数调用前创建 [x] 如果一端主动关闭管道，另一端的读写操作会直接返回0 进程之间的通信方式 – 消息队列消息队列是独立于两个进程之外的这样一个方式，它跟之前说的共享内存挺像，它是独立于进程之外的一片特殊空间， [x] 指定一个key 值来创建一个消息队列 [x] 在消息队列中传递的数据有大小限制 65535 (int) 的默值 [x] 消息队列不像管道类似TCP传递而更像udp这样的流式传递，我发给你一个数据包，另一个进程去读，读的时候也是一个一个去读 [x] 消息队列会一直保留直到被主动关闭 序章-IO多路复用 如图所示，有5个fd(描述符)注册在这个epoll函数里，它就会不停的去监听这5个描述符，比如某一个描述符有来自客户端的数据了，某一个描述符可以准备开始往客户端写数据了，或者某一个描述符被关闭了，诸如此类事件发生了，epoll 函数才会效应，并返回有这些事件发生的socket集合，让客户端再一个一个去处理，所以你会发现它并不是异步的，epoll 它的优点是可以处理大量的socket连接， [x] epoll函数会监听注册在自己名下的描述符 [x] 当有socket感兴趣的事件发生时，epoll函数才会效应，并返回有事件发生的socket集合 [x] epoll的本质是阻塞IO，它的优点在于能同时处理大量的socket连接 Event Loop实际上swoole 提供的epoll上层的封装，并且提供了一个线程，当使用swoole evente一些列函数去发起创建一个事件循环的时候，swoole会在底层启动一个reactor线程，这个线程中会运行一个epoll实例并且它会去我们需要去注册描述符到这个epoll实例中并为它建立read与write的监听 [x] Event Loop 实际上就是一个Reactor线程，其中运行了一个epoll 实例 [x] 可通过接口添加socket 描述符到epoll监听中，并指定事件响应的回调函数 [x] 因为它是新起的线程去运行的，Event Loop 不可用于FPM 环境中 Event Loop实例 命令行聊天室 主要应用点： 异步读取来自服务器的数据 异步读取来自终端的输入 手动退出聊天室增加 12bool swoole_event_add(int $sock, mixed $read_callback, mixed $write_callback = null, int $event_flag = null); 修改，比如之前增加了一个描述符在里面并为它绑定了一个回调，那么后面我想修改它比如我这个时候不想让它继续监听写事件了或者想把它的监听关掉，那么都可以通过这个函数重新设定它，重新设定的时候注意一下如果我们穿进去的$fd之前是没有add的话会报错 1bool swoole_event_set($fd, mixed $read_callback, mixed $write_callback, int $flag); 当我们某个描述符不需要的时候可以通过del方法将它删除 1bool swoole_event_del(int $sock); 当我们整个事件都不想要的话我们可以通过exit退出整个事件轮询，把epoll这个实例关掉，这个只能在client 中调用 1bool swoole_event_del(int $sock); 读事件是在我们加入的读回调中执行的，当我们需要异步的将某个socket中写的时候swoole 也提供了一个event_write函数,这个write就会把这个消息的发送变成异步的，当我们发送缓冲区满了的之后swoole就会将数据发送到发送队列里来监听它可写，底层会自动执行写的事件，我们不需要再代码中再去关注缓存的问题 实例-命令行聊天室 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php/** * 一个简单的命令行聊天室 * User: pushaowei * Date: 2016/9/11 0011 * Time: 12:53 */class server&#123; private $serv; public function __construct()&#123; header("content-type:text/html;charset=utf8"); $this-&gt;serv = new swoole_server("0.0.0.0",9501); $this-&gt;serv -&gt;set (['worker_num' =&gt; 1]); $this-&gt;serv -&gt;on('Start',[$this,'onStart']); $this-&gt;serv -&gt;on('Connect',[$this,'onConnect']); $this-&gt;serv -&gt;on('Receive',[$this,'onReceive']); $this-&gt;serv -&gt;on('Close',[$this,'onClose']); $this-&gt;serv -&gt;start(); &#125; /** * start * @param $serv */ public function onStart($serv)&#123; echo "咱们连接已经建立成功啦\n"; &#125; /** * 建立连接 * @param $serv * @param $fd * @param $form_id */ public function onConnect($serv,$fd,$form_id)&#123; echo "Client &#123;$fd&#125; connect\n"; &#125; /** * 服务端关闭提示 * @param $serv * @param $fd * @param $form_id */ public function onClose($serv,$fd,$form_id)&#123; echo "Client &#123;$fd&#125; close connection \n"; &#125; /** * 当我们收到客户端的消息时简单的广播出去 * @param swoole_server $serv * @param $fd * @param $form_id * @param $data */ public function onReceive(swoole_server $serv,$fd,$form_id,$data)&#123; echo "Get Message From Client &#123;$fd&#125; : &#123;$data&#125;\n"; foreach($serv-&gt;connections as $v)&#123; if($fd != $v)&#123; $serv-&gt;send($v,$data); &#125; &#125; &#125;&#125;$server = new Server(); 作者还没学习客户端怎么玩所以依然是使用瑞士军刀nc工具代替 12[pushaowei@localhost www]$ nc 127.0.0.1 9501 然后作者觉得 ，老是用工具就不好玩了，于是又写了一份客户端的连接供大家玩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * 比较简陋的客户端. * User: pushaowei * Date: 2016/9/11 0011 * Time: 13:39 *///通过stream方法生成了一个具体的描述符，通过tcp方式连接了服务器$socket = stream_socket_client("tcp://127.0.0.1:9501",$errno,$errstr,30);/*STDIN 标准的输入设备STDOUT 标准的输出设备STDERR 标准的错误设备可以在PHP脚本里使用这三个常量，以接受用户的输入，或者显示处理和计算的结果。现在就有小明和二狗两个人在这个聊天室里聊天*//** * 读监听，当客户端小明发送到服务器的数据后这里会被读到，然后转发给二狗 */function onRead()&#123; global $socket; $buffer = stream_socket_recvfrom($socket,1024); if(!$buffer)&#123; echo "Server closed\n"; swoole_event_del($socket); &#125; echo "\n刚刚有人说:&#123;$buffer&#125;\n"; fwrite(STDERR,"Enter Msg:");&#125;/** * 发送数据 */function onWrite()&#123; global $socket; echo "on Write\n";&#125;/** * 发送操作 */function onInput()&#123; global $socket; $msg = trim(fgets(STDIN)); //如果键入 exit 的话就选择退出 if($msg == 'exit')&#123; swoole_event_exit(); exit(); &#125; swoole_event_write($socket,$msg); fwrite(STDOUT,"Enter Msg:");&#125;//给$socket描述符设置了两个方法一个读一个写swoole_event_add($socket,'onRead','onWrite');//监听了标准输入，设置了input的函数，当它监听到来自键盘的输入后它来获取输入了啥内容，然后发送给客户端swoole_event_add(STDIN,'onInput');//登录聊天室蹦出来的fwrite(STDOUT,"Enter Msg:"); 异步读取来自服务器的数据 异步读取来自终端的输入 手动退出聊天室 Event Loop 的常见问题 Q:为什么开启Event loop 的程序会一直运行不停止A:开始Event Loop 后程序会启动一个线程并一直阻塞在epoll的监听上，它是一个whlie的循环不断监听这个事件直到我们调用exit，因此不会退出， Q:如何关闭 Event Loop ？A:调用swoole_event_exit函数即可关闭事件循环(swoole_server中此函数无用，这个只能用在client中)这个rectaor 不能关闭 Swoole_Process相关这个process主要呢就是来替代PHP的pcntl扩展。 swoole_process提供了基于unixsock的进程间通信，使用很简单只需调用write/read或者push/pop即可 swoole_process支持重定向标准输入和输出，在子进程内echo不会打印屏幕，而是写入管道，读键盘输入可以重定向为管道读取数据 swoole_process允许用于fpm/apache的Web请求中配合swoole_event模块，创建的PHP子进程可以异步的事件驱动模式 swoole_process提供了exec接口，创建的进程可以执行其他程序，与原PHP父进程之间可以方便的通信 一个swoole_process对象除了它本身是一个进程之外，它还有三个比较重要的内容 所有的swoole_process通过参数指定它都会创建一个管道，子进程到父进程的通信管道，通过管道我们就可以实现进程之间的通信，每个swoole_process的进程空间是独立的 基于C语言封装的进程管理模块， 方便php的多进程通信 内置管道和消息队列的通信接口，可通过参数或API开启或关闭，很容易就进行进程间的通信 提供自定义的信号管理 创建子进程 12345678int swoole_process::__construct(mixed $function, $redirect_stdin_stdout = false, $create_pipe = true);//$function，子进程创建成功后要执行的函数,就是函数创建之后将要做什么//$redirect_stdin_stdout，重定向子进程的标准输入和输出。 启用此选项后，在进程内echo将不是打印屏幕，而是写入到管道。读取键盘输入将变为从管道中读取数据。 默认为阻塞读取。//$create_pipe，是否创建管道，启用$redirect_stdin_stdout后，此选项将忽略用户参数，强制为true 如果子进程内没有进程间通信，可以设置为false 启动进程 123456int swoole_process-&gt;start();//创建成功返回子进程的PID，创建失败返回false。可使用swoole_errno和swoole_strerror得到错误码和错误信息。$process-&gt;pid 属性为子进程的PID$process-&gt;pipe 属性为管道的文件描述符 来个实例玩玩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php/** * swoole_process. * User: pushaowei * Date: 2016/9/11 0011 * Time: 14:59 */class BaseProcess&#123; private $process; /** * BaseProcess constructor. */ public function __construct()&#123; $this-&gt;process = new swoole_process([$this,'run'],false,true); //$this -&gt; proccess -&gt; daemon(true,true); $this-&gt;process -&gt;start(); swoole_event_add($this-&gt;process-&gt;pipe,function($pipe)&#123; $data = $this-&gt;process-&gt;read(); echo"RECV ".$data.PHP_EOL; &#125;); &#125; /** * @param $worker */ public function run($worker)&#123; swoole_timer_tick(1000, function ($timer_id) &#123; static $num = 0; $num += + 1; $this-&gt;process-&gt;write("Hello"); var_dump($num); if ($num == 10) &#123; //输出十次就退出 swoole_timer_clear($timer_id); &#125; &#125;); &#125;&#125;new BaseProcess();//监听到进程退出了swoole_process::signal(SIGCHLD,function($sig)&#123; //必须为false while($ret = swoole_process::wait(false))&#123; echo "PID = &#123;$ret['pid']&#125;\n"; &#125;&#125;); proccess 实例消息队列式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php/** * swoole_process. 消息队列式 * User: pushaowei * Date: 2016/9/11 0011 * Time: 14:59 */class BaseProcess&#123; private $process; /** * BaseProcess constructor. */ public function __construct()&#123; $this-&gt;process = new swoole_process([$this,'run'],false,true); //创建一个消息队列并制定key值为123 if(!$this-&gt;process-&gt;useQueue(123))&#123; var_dump(swoole_strerror(swoole_error())); exit; &#125; $this -&gt; process-&gt;start(); while(true)&#123; $data = $this -&gt;process-&gt;pop(); echo "RECV :".$data.PHP_EOL; &#125; &#125; /** * @param $worker */ public function run($worker)&#123; swoole_timer_tick(1000, function ($timer_id) &#123; static $num = 0; $num += + 1; $this-&gt;process-&gt;write("Hello"); var_dump($num); if ($num == 10) &#123; //输出十次就退出 swoole_timer_clear($timer_id); &#125; &#125;); &#125;&#125;new BaseProcess();//监听到进程退出了swoole_process::signal(SIGCHLD,function($sig)&#123; //必须为false while($ret = swoole_process::wait(false))&#123; echo "PID = &#123;$ret['pid']&#125;\n"; &#125;&#125;); 动态进程池 使用tick 函数定时投递任务 动态进程池，根据任务执行的多条动态调整内存池的大小 使用特性 tick定时任务 swoole_process 管道通信 Event loop 事件循环 看下源码应该就直观一点了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?php/** * swoole_process. 消息队列式 * User: pushaowei * Date: 2016/9/11 0011 * Time: 14:59 */class BaseProcess&#123; private $process; private $process_list = []; //对应的子进程的数组 private $process_use = []; //标记进程是否使用当中 private $min_worker_num = 3; //最小的worker private $max_worker_num = 6; //最大的worker private $current_num; //当前worker 标记 /** * BaseProcess constructor. */ public function __construct()&#123; $this-&gt;process = new swoole_process([$this,'run'],false,2);//启动的一个父进程 $this-&gt;process -&gt; start(); swoole_process::wait(); &#125; /** * @param $worker * 任务进程池 */ public function run($worker)&#123; //这里可以执行sql $this-&gt;current_num = $this -&gt;min_worker_num; for($i=0 ;$i&lt; $this-&gt;current_num;$i++)&#123; $process = new swoole_process([$this,'task_num'],false,2); $pid = $process-&gt;start(); $this-&gt;process_list[$pid] = $process; $this-&gt;process_use[$pid] = 0; &#125; foreach($this-&gt;process_list as $v)&#123; swoole_event_add($v-&gt;pipe,function($pipe) use ($v)&#123; $data = $v -&gt; read(); var_dump($data); $this-&gt;process_use[$data] = 0; &#125;); &#125; /** * 每一秒钟去发一次任务 */ swoole_timer_tick(1000,function($timer_id)&#123; static $num = 0; $num += 1; $flag = true; //它去看看哪一个进程是没有被使用的 foreach($this-&gt;process_use as $k =&gt; $v )&#123; if($v == 0)&#123; $flag =false; $this-&gt;process_use[$k] = 1; //并且把它标记成1 在给它发个任务 $this-&gt;process_list[$k] -&gt;write($num ."hello"); break; &#125; &#125; //如果所有的worker子进程都再忙着了，再当前进程池还没满的情况下启动一个新的进程池 if($flag &amp;&amp; $this-&gt;current_num &lt; $this-&gt;max_worker_num)&#123; $process = new swoole_process([$this,'task_num'],false,2); $pid = $process -&gt;start(); $this-&gt;process_list[$pid] = $process ; $this-&gt;process_use[$pid] = 1; $this-&gt;process_list[$pid] -&gt;write($num."Hello"); &#125; var_dump($num);//如果执行完十次任务后 关闭当前定时器关闭当前子进程 if($num == 10)&#123; foreach($this-&gt;process_list as $v)&#123; $v -&gt; write('exit'); &#125; swoole_timer_clear($timer_id); $this-&gt;process-&gt;exit(); &#125; &#125;); &#125; public function task_num($worker)&#123; //当读到父进程发送来的任务时 swoole_event_add($worker-&gt;pipe,function($pipe) use ($worker)&#123; $data = $worker-&gt;read(); //当某个子进程收到任务的时候，它会打印自己的进程号，和它所接到的任务的消息 var_dump($worker-&gt;pid.":".$data); if($data =='exit')&#123; $worker-&gt;exit();exit; sleep(5); $worker -&gt; write("",$worker-&gt;pid); &#125; &#125;); &#125;&#125;new BaseProcess();//监听到进程退出了swoole_process::signal(SIGCHLD,function($sig)&#123; //必须为false while($ret = swoole_process::wait(false))&#123; echo "PID = &#123;$ret['pid']&#125;\n"; &#125;&#125;); process 连接池与 task连接池有什么优缺点 task worker 它的数目相对来说是固定的， process 是不太稳定的，因为它是动态加子进程的，通过定时器发任务的，它的任务耗时比较长，动态扩展进程池，处理更多的任务; 管道是两个描述符。读和写，当父进程创建这个管道后，然后在创建两个子进程，父进程中比如有两个管道，管1，管2，那么子进程也拥有两个管道，一个读一个写，读的那个只能用来读，写的那个只能用来写]]></content>
      <categories>
        <category>publish</category>
      </categories>
      <tags>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole 学习第一章 Task进程与Timer进程]]></title>
    <url>%2F2016%2F09%2F10%2Fswoole_1%2F</url>
    <content type="text"><![CDATA[Swoole 据说是可以php革命的一个东西，更有屌丝说看见swoole如见php的未来一般,作者不才看官方教程实在迷糊，特意花大洋买了视频来看，希望与大家共同进步 Swoole 据说是可以php革命的一个东西，更有屌丝说看见swoole如见php的未来一般,作者不才看官方教程实在迷糊，特意花大洋买了视频来看，希望与大家共同进步 补坑环节 介绍swoole进程的基本知识 介绍task进程的原理，使用方法和常见问题的解决方法 介绍如何使用定时器，定时器使用的一些小技巧和调试方法 装逼环节 补坑环节 什么是进程，所谓进程其实就是操作系统中一个正在运行的程序，我们在一个终端当中，通过php，运行一个php文件，这个时候就相当于我们创建了一个进程，这个进程会在系统中驻存，申请属于它自己的内存空间系统资源并且运行相应的程序 那么我们将这个模型做一下简化，对于一个进程来说，它的核心内容分为两个部分，一个是它的内存，这个内存是这进程创建之初从系统分配的，它所有创建的变量都会存储在这一片内存环境当中 一个是它的上下文环境我们知道进程是运行在操作系统的，那么对于程序来说，它的运行依赖操作系统分配给它的资源，操作系统的一些状态，以及它自己的一些状态，这些都构成了这个进程的上下文环境 在操作系统中可以运行多个进程的，对于一个进程来说，它可以通过一个系统函数创建自己的子进程，那么当我们在一个进程中创建出若干个子进程的时候那么可以看到如图，我们以两个方框代表父进程创建出来的子进程，那么子进程和父进程一样，拥有自己的内存空间和上下文环境 需要注意的是，在创建出来的新的子进程当中，它会复制自己的父进程的内存空间和上下文环境，也就是说子进程自己的内存空间和父进程的内存空间是独立的，相互没有任何影响的，如果修改子进程当中的某个变量，它不会影响自己的父进程，我们在父进程中创建一个变量$temp ,那么它的两个子进程当中也有$temp [x] 子进程会复制父进程的内存空间和上下文环境 [x] 修改某个子进程的内存空间，不会修改父进程或其他子进程中的内存空间 [x] Swoole本身也是一个多进程的模型，它有多个worker进程和自己master进程,那么多个worker进程中创建的变量之间是不能通用的 共享内存上面我们说了，进程当中的变量是不能通用的，那我怎么实现两个进程之间的通信呢？如图我们看到有一个子进程1和子进程2 他们拥有不同的内存空间和上下文环境，那么我们想实现它们之间的通信的话就可以用我们的共享内存，共享内存在操作系统中比较一个特殊的内存，它并不依赖于进程而存在，并不属于任何进程，我们可以调用系统提供的系统函数，来创建一片共享内存并指定它的索引，通过索引任何一个进程都可以在这片共享内存中申请内存空间，并在其中储存对应的值 [x] 共享内存不属于任何一个进程 [x] 在共享内存中分配的内存空间可以被任何进程访问，只要这个进程拥有这片共享内存的索引 [x] 即使进程关闭，共享内存任然可以继续保留在操作系统当中 举例来说，当子进程1 通过索引在共享内存中分配了一片内存并将它命名为 $a并赋值为vg,那么子进程2中同样可以去访问这个$a并且 得到vg这个值，它也可以修改这个值，同样子进程1可以通过变量得到这个修改，这样它们就实现了两个子进程之间的通信啦 可以通过几个命令来看一下 12345[pushaowei@localhost ~]# ipcs -m------ Shared Memory Segments --------key shmid owner perms bytes nattch status0x00000000 0 root 600 524288 21 dest 当程序 生成了一片共享内存过后，key值是我们创建共享内存中所申明的。shmid就是这个共享内存的索引，我们可以通过这个id来访问指定的 内存空间,owner是创建内存的用户，perms 是它的访问权限，bytes是它的大小 Swoole 的结构在swoole 没出现之前，php写web开发的时候需要依赖nginx 这样的web应用服务器并且依赖fpm的解析的 ,fpm大家都知道它同样是一个多进程的php解析器，当一个新的请求过来的时候fpm会创建一个新的进程去处理这个请求，这样的话系统的开销是用于创建和销毁进程，导致整个程序的效应效率并不是十分的高，那么在swoole当中，swoole采用和fpm完全不用的架构，如图所示，整个swoole扩展可以分为三层 [ ] 第一层，Master进程，这个是swoole的主进程,这个进程是用于处理swoole的核心事件驱动的，那么在这个进程当中可以看到它拥有若干个Reactor[线程]，swoole所有对于事件的监听都会在这些线程中实现，比如来自客户端的连接，本地通信用的管道，以及异步操作用到的描述符 [ ] Manager进程，创建管理更下一层的Worker进程以及Task Worker 进程，它仅仅做分配 [ ] Worker进程以及Task worker 进程，worker 进程属于swoole的主逻辑进程，用户处理客户端的一系列请求，再往下一层是taskworker进程这一进城是swoole提供的异步工作进程，这些进程主要用于处理一些耗时较长的同步任务， 在swoole 当中进程与进程之间的通信是通过管道来实现的， 在master进程当中当Reactor接收到了来自客户端的数据的时候，这些数据会通过管道发送给Worker进程由Worker进程进行处理，那么 Worker进程需要投递任务到Task Worker进程当中的时候也是通过管道来实现数据投递，我们可以通过设置swoole的配置参数来使得task与 worker 进程之间的通信走系统的消息队列 当客户端的一个新的连接过来时，会被 Main Reactor 线程接收到，然后将这个连接读写操作的监听，注册到对应的Reactor线程当中，并通知Worker进程处理对应的OnClient，也就是接收到连接的回调，当Worker进程出现意外，或出现一定的请求次数关闭后，Manager进程会重新发起一个新的Worker进程，保证系统当中的Worker进程的数目是固定的，这样一来就完成了整个swoole扩展的结构 Task 进程以及Task Worker进程task 进程是独立于worker进程当中的一个工作进程，用于处理一些耗时较长的逻辑，这些逻辑如果在task 进程当中处理时并不会影响worker 进程处理来自客户端的请求，由此大大提高了swoole处理并发的能力 如图可以看到在worker进程到中，我们调用对应的task()方法发送数据通知到task worker 进程，task worker进程会在onTask()回调中 接收到这些数据，并进行处理，处理完成之后通过调用finsh()函数或者直接return返回消息给worker进程，worker进程在onFinsh()进程收到这些消息并进行处理 [x] 两个进程之间是通过Unix Sock 管道通信(也可配置通过消息队列通信); Task Worker 的使用 使用linux nc 工具可以模拟客户端连接1[pushaowei@localhost www]# nc 127.0.0.1 9501 开启 task 123$serv-&gt;set(array( 'task_worker_num' =&gt; 8)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpclass Server&#123; private $serv; public function __construct() &#123; $this-&gt;serv = new swoole_server("0.0.0.0", 9501); $this-&gt;serv-&gt;set(array( 'worker_num' =&gt; 8, 'daemonize' =&gt; false, 'max_request' =&gt; 10000, 'dispatch_mode' =&gt; 2, 'debug_mode'=&gt; 1, 'task_worker_num' =&gt; 8 )); $this-&gt;serv-&gt;on('Start', array($this, 'onStart')); $this-&gt;serv-&gt;on('Connect', array($this, 'onConnect')); $this-&gt;serv-&gt;on('Receive', array($this, 'onReceive')); $this-&gt;serv-&gt;on('Close', array($this, 'onClose')); // bind callback $this-&gt;serv-&gt;on('Task', array($this, 'onTask')); $this-&gt;serv-&gt;on('Finish', array($this, 'onFinish')); $this-&gt;serv-&gt;start(); &#125; public function onStart( $serv ) &#123; //创建连接要经历的 echo "Start\n"; &#125; public function onConnect( $serv, $fd, $from_id ) &#123; //客户端有连接过来会发起的，有几个连接就有几个fd echo "Client &#123;$fd&#125; connect\n"; &#125; public function onReceive( swoole_server $serv, $fd, $from_id, $data ) &#123; //客户端发送来的数据就跑到这里来了，fd就是第几个连接上的 echo "来自客户端的请求 本次的fd为 &#123;$fd&#125;:&#123;$data&#125;\n"; // 如果我们收到了来自客户端的数据，需要创建一个任务，我们可以通过这样的方式 //首先我们创建一个数组用于存放需要传递给task的数据 $param =[ 'task' =&gt;'task_1', //task任务 'param' =&gt; $data, //收到来自客户端的数据传递给它 'fd' =&gt; $fd //客户端的描述符也给它传递过去 ]; $serv-&gt;task( json_encode( $param ) ); //通过serv的task方法将数据传递出去，task传递的时候只能传递一个字符串，需要用json或者序列化将这个数据处理 &#125; public function onClose( $serv, $fd, $from_id ) &#123; echo "Client &#123;$fd&#125; close connection\n"; &#125; public function onTask($serv,$task_id,$from_id, $data) &#123; //onTask回调中会收到onReceive发来的这个任务， echo "这次发送过来的task_id 为 &#123;$task_id&#125; 我们的from_id 为 &#123;$from_id&#125;\n"; $data = json_decode($data,true); //解析发送来的数据 echo "Receive Task :&#123;$data['task']&#125;\n"; var_dump($data['param']); //打印客户端发来的数据 $serv-&gt;send( $data['fd'], "hello task task_id == &#123;$task_id&#125;"); //这是发给客户端的 //处理完成之后调用send函数通过接收到的描述符给客户端发送数据 return "Task &#123;$task_id&#125;'s result"; //然后return 返回给worker 进程 告诉他们想说的 &#125; public function onFinish($serv,$task_id, $data) &#123; //onFinish收到上面回来的消息就可以将这个data 打印出来 echo "Task &#123;$task_id&#125; finish\n"; echo "Result: &#123;$data&#125;\n"; &#125;&#125;$server = new Server(); Task 常见问题 task 传递数据最好小于8K，如果数据大于8k 超过swoole buff 空间后这些数据会被swoole 写入临时文件/tmp进行传递，那么在onTask接收到实际的任务的时候，他会去读取这个文件将这个数据读出来 task 传递对象可以通过序列化传递一个对象的拷贝，task中对对象的改变不会反映到worker进程中数据库连接网络连接对象不可传递 task onFinsh 回调会发回调用task方法的worker 进程 mysql 连接池先来整个数据库1234567create database test charset 'utf8';use test; create table vg( -&gt; id int unsigned auto_increment, -&gt; value char(10) not null default'', -&gt; primary key(id) -&gt; )engine=InnoDb; 上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;?php/** 1. Class MySqlPlool by:pushaowei */class MySqlPlool&#123; private $serv; private $pdo; public function __construct()&#123; $this-&gt;serv = new swoole_server('127.0.0.1',9502); $this-&gt;serv -&gt;set([ 'worker_num' =&gt;8, 'daemonize' =&gt;false, 'max_request' =&gt;10000, 'dispatch_mode' =&gt;3, 'debug_mode' =&gt;1 , 'task_worker_num' =&gt;8 ]); $this-&gt;serv-&gt;on('WorkerStart', array($this, 'onWorkerStart')); $this-&gt;serv-&gt;on('Connect', array($this, 'onConnect')); $this-&gt;serv-&gt;on('Receive', array($this, 'onReceive')); $this-&gt;serv-&gt;on('Close', array($this, 'onClose')); // bind callback $this-&gt;serv-&gt;on('Task', array($this, 'onTask')); $this-&gt;serv-&gt;on('Finish', array($this, 'onFinish')); $this-&gt;serv-&gt;start(); &#125; /** * [onConnect 创建连接] * @param [type] $serv [description] * @param [type] $fd [description] * @param [type] $from_id [description] * @return [type] [description] */ public function onConnect($serv, $fd ,$from_id )&#123; echo "Client &#123;$fd&#125; connect \n"; &#125; /** * [onWorkerStart 创建pdo连接,woker进程创建之初被调用] * @param [type] $serv [description] * @param [type] $worker_id [description] * @return [type] [description] */ public function onWorkerStart($serv, $worker_id)&#123; echo "onWorkerStart\n"; $this-&gt;pdo = new PDO("mysql:dbname=test;host=127.0.0.1",'root','123456'); $this-&gt;pdo -&gt; exec('SET NAMES utf8');//设置通信编码 $this-&gt;pdo -&gt; setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); &#125; /** * [onReceive 这里收到客户端的请求] * @param swoole_server $serv [description] * @param [type] $fd [description] * @param [type] $from_id [description] * @param [type] $data [description] * @return [type] [description] */ public function onReceive (swoole_server $serv ,$fd , $from_id ,$data )&#123; $task= [ 'sql' =&gt;'insert into vg values (?,?)', 'params' =&gt; ['',$fd], 'fd' =&gt; $fd //描述符 ]; $serv -&gt;task(json_encode($task)); &#125; /** * [onTask 处理sql,接收客户端的$data] * @param [type] $serv [description] * @param [type] $task_id [description] * @param [type] $from_id [description] * @param [type] $data [description] * @return [type] [description] */ public function onTask($serv,$task_id,$from_id,$data)&#123; echo '已经跑onTask这里来啦'; try&#123; $data = json_decode($data,true); $stement = $this-&gt;pdo-&gt;prepare($data['sql']); $stement -&gt;execute($data['params']); $serv-&gt;send($data['fd'],'insert succed'); //将返回结果给客户端 return true; &#125;catch(PDOException $e) &#123; var_dump($e-&gt;getMessage()); return false; &#125; &#125; /** * [onFinish description] * @param [type] $serv [description] * @param [type] $task_id [description] * @param [type] $data [description] * @return [type] [description] */ public function onFinish($serv,$task_id,$data)&#123; var_dump("resut:" .$data); &#125; /** * @param $serv * @param $fd * @param $from_id */ public function onClose( $serv, $fd, $from_id ) &#123; echo "Client &#123;$fd&#125; close connection \n"; &#125;&#125;new MySqlPlool(); 说说都发生了什么，通过N个task进程来维持数据库操作，每个task进程中都有一个pdo实例然后通过数据库连接来实现一个异步的数据库操作，onWorkerStart这个会在worker进程创建之初被回调，它并不区分自己是worker进程还是task worker进程,我们需要通过代码进行控制，123456789101112public function onWorkerStart($serv, $worker_id)&#123; echo "onWorkerStart\n"; // //让它只有是taskworker的时候才创建pdo连接 if($serv -&gt; taskworker)&#123; $this-&gt;pdo = new PDO("mysql:dbname=test;host=127.0.0.1",'root','123456'); $this-&gt;pdo -&gt; exec('SET NAMES utf8');//设置通信编码 $this-&gt;pdo -&gt; setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION); &#125; else echo "我们只让taskworker连";&#125; 运行结果1234567891011121314151617[pushaowei@localhost www]# php server.php我们只让task worker 连接我们只让task worker 连接我们只让task worker 连接我们只让task worker 连接我们只让task worker 连接我们只让task worker 连接taskWorkerStarttaskWorkerStart我们只让task worker 连接taskWorkerStart我们只让task worker 连接taskWorkerStarttaskWorkerStarttaskWorkerStarttaskWorkerStarttaskWorkerStart 出现的worker 与前面咱们设定的值对应12345678$this-&gt;serv -&gt;set([ 'worker_num' =&gt;8, 'daemonize' =&gt;false, 'max_request' =&gt;10000, 'dispatch_mode' =&gt;3, 'debug_mode' =&gt;1 , 'task_worker_num' =&gt;8 ]); Timer定时器Timer定时器 是Swoole提供的一个内置功能，这个功能提供精度更高的毫秒级的定时器 基于Reactor 线程(在task worker 中使用系统定时器); 基于epoll的timeout 机制实现 为了提高timer的检索效率，在swoole中实现了一个堆来存放timer，这个堆是一个最小堆，它的存放的索引是每个timer定时器的 距离下一次相应剩余的时间，这个时间越小这个timer就在堆中所放的位置就会离堆顶越近，每次遍历的时候都会从堆顶往下检索，每一次下沉索引都会检测到剩余时间越长的timer，当最上面的timer可以运行的时候我们只需要遍历少量的timer都可以将所有的timer从这个堆中取出来，提高了 检索的效率 timer-使用一共有两种定时器12int swoole_timer_tick(int $ms, mixed $callback, mixed $param = null);int swoole_timer_after(int $after_time_ms, mixed $callback_function); tick 是创建一个永久的定时器，这个定时器会在swoole 一直运行，并在指定的毫秒间隔每隔一段时间执行一次，并调用指定的$callback函数，after 是指定一个临时的一次性的定时器，这个定时器会在$after_time_ms指定毫秒数后调用这个$callback_function方法12345678910public function onWorkerStart($serv, $worker_id)&#123; //当worker id =0 的时候我们才创建这个tick if($worker_id == 0) &#123; swoole_timer_tick(1000, function($timer_id,$parmas)&#123; echo "QQ:542684913\n"; echo "&#123;$parmas&#125; \n"; &#125;, "hello"); &#125;&#125; timer 常见问题可以通过tick方法的第三个参数传递，也可以使用use 闭包来传递一个参数进去，onTimer 是在调用tick方法的进程中回调，因此可以直接使用在Worker进程中申明的对象（局部变量无法访问）；tick方法会返回timer_id 可以使用swoole_timer_clear清除指定的定时器 timer实例Swoole Crontab Crontab是linux上的一个定时程序，它的实现最小为分钟，我们可以设置swoole crontab实现一个更精确的定时原理：使用tick方法，每1s 检查一次crontab 任务表，如果发现有需要执行的任务，就通知worker进程处理任务,步骤 解析crontab文件，并存入DB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114?php/** * Created by PhpStorm. * User: ClownFish 542684913@qq.com * Date: 14-12-27 * Time: 上午11:59 */class ParseCrontab&#123; static public $error; /** * 解析crontab的定时格式，linux只支持到分钟/，这个类支持到秒 * @param string $crontab_string : * * 0 1 2 3 4 5 * * * * * * * * - - - - - - * | | | | | | * | | | | | +----- day of week (0 - 6) (Sunday=0) * | | | | +----- month (1 - 12) * | | | +------- day of month (1 - 31) * | | +--------- hour (0 - 23) * | +----------- min (0 - 59) * +------------- sec (0-59) * @param int $start_time timestamp [default=current timestamp] * @return int unix timestamp - 下一分钟内执行是否需要执行任务，如果需要，则把需要在那几秒执行返回 * @throws InvalidArgumentException 错误信息 */ static public function parse($crontab_string, $start_time = null) &#123; if (is_array($crontab_string)) &#123; return self::_parse_array($crontab_string, $start_time); &#125; if (!preg_match('/^((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)$/i', trim($crontab_string))) &#123; if (!preg_match('/^((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)\s+((\*(\/[0-9]+)?)|[0-9\-\,\/]+)$/i', trim($crontab_string))) &#123; self::$error = "Invalid cron string: " . $crontab_string; return false; &#125; &#125; if ($start_time &amp;&amp; !is_numeric($start_time)) &#123; self::$error = "\$start_time must be a valid unix timestamp ($start_time given)"; return false; &#125; $cron = preg_split("/[\s]+/i", trim($crontab_string)); $start = empty($start_time) ? time() : $start_time; if (count($cron) == 6) &#123; $date = array( 'second' =&gt; self::_parse_cron_number($cron[0], 0, 59), 'minutes' =&gt; self::_parse_cron_number($cron[1], 0, 59), 'hours' =&gt; self::_parse_cron_number($cron[2], 0, 23), 'day' =&gt; self::_parse_cron_number($cron[3], 1, 31), 'month' =&gt; self::_parse_cron_number($cron[4], 1, 12), 'week' =&gt; self::_parse_cron_number($cron[5], 0, 6), ); &#125; elseif (count($cron) == 5) &#123; $date = array( 'second' =&gt; array(1 =&gt; 1), 'minutes' =&gt; self::_parse_cron_number($cron[0], 0, 59), 'hours' =&gt; self::_parse_cron_number($cron[1], 0, 23), 'day' =&gt; self::_parse_cron_number($cron[2], 1, 31), 'month' =&gt; self::_parse_cron_number($cron[3], 1, 12), 'week' =&gt; self::_parse_cron_number($cron[4], 0, 6), ); &#125; if ( in_array(intval(date('i', $start)), $date['minutes']) &amp;&amp; in_array(intval(date('G', $start)), $date['hours']) &amp;&amp; in_array(intval(date('j', $start)), $date['day']) &amp;&amp; in_array(intval(date('w', $start)), $date['week']) &amp;&amp; in_array(intval(date('n', $start)), $date['month']) ) &#123; return $date['second']; &#125; return null; &#125; /** * 解析单个配置的含义 * @param $s * @param $min * @param $max * @return array */ static protected function _parse_cron_number($s, $min, $max) &#123; $result = array(); $v1 = explode(",", $s); foreach ($v1 as $v2) &#123; $v3 = explode("/", $v2); $step = empty($v3[1]) ? 1 : $v3[1]; $v4 = explode("-", $v3[0]); $_min = count($v4) == 2 ? $v4[0] : ($v3[0] == "*" ? $min : $v3[0]); $_max = count($v4) == 2 ? $v4[1] : ($v3[0] == "*" ? $max : $v3[0]); for ($i = $_min; $i &lt;= $_max; $i += $step) &#123; $result[$i] = intval($i); &#125; &#125; ksort($result); return $result; &#125; static protected function _parse_array($crontab_array, $start_time) &#123; $result = array(); foreach ($crontab_array as $val) &#123; if(count(explode(":",$val)) == 2)&#123; $val = $val.":01"; &#125; $time = strtotime($val); if ($time &gt;= $start_time &amp;&amp; $time &lt; $start_time + 60) &#123; $result[$time] = $time; &#125; &#125; return $result; &#125;&#125; 在tick的回调中，检查所有的crontab任务，找到满足当前时序的任务，并执行]]></content>
      <categories>
        <category>publish</category>
      </categories>
      <tags>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaf---异常和错误 | 路由和分发]]></title>
    <url>%2F2016%2F07%2F31%2Fyaf04%2F</url>
    <content type="text"><![CDATA[Yaf实现了一套错误和异常捕获机制, 主要是对常见的错误处理和异常捕获方法做了一个简单抽象, 方便应用组织自己的错误统一处理逻辑。前题是需要配置过或是在程序中启用 使用示例Yaf实现了一套错误和异常捕获机制, 主要是对常见的错误处理和异常捕获方法做了一个简单抽象, 方便应用组织自己的错误统一处理逻辑。前题是需要配置过或是在程序中启用 配置 application.dispatcher.throwException=1 application.dispatcher.catchException=1 在程序中启用 Yaf_Dispatcher::throwException(true) 在application.dispatcher.catchException(配置文件, 或者可通过Yaf_Dispatcher::catchException(true))开启的情况下, 当Yaf遇到未捕获异常的时候, 就会把运行权限, 交给当前模块的Error Controller的Error Action动作, 而异常或作为请求的一个参数, 传递给Error Action. 新建一个Error Controller &lt;?php class ErrorController extends Yaf_Controller_Abstract { public function errorAction($exception) { assert($exception); $this-&gt;getView()-&gt;assign(&quot;code&quot;, $exception-&gt;getCode()); $this-&gt;getView()-&gt;assign(&quot;message&quot;, $exception-&gt;getMessage()); $this-&gt;getView()-&gt;assign(&quot;line&quot;, $exception-&gt;getLine()); } } ?&gt; 新建一个Error显示模板文件 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Error Page &lt;{$code}&gt;&lt;/title&gt; &lt;style&gt; body{background-color:#f0c040} h2{color:#fafafa} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Error Page&lt;/h2&gt; &lt;p&gt;Error Code:&lt;{$code}&gt;&lt;/p&gt; &lt;p&gt;Error Message:&lt;{$message}&gt;&lt;/p&gt; &lt;p&gt;Error Line:&lt;{$line}&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在Bootstrap.php中新建一个error_handler方法 public static function error_handler($errno, $errstr, $errfile, $errline) { if (error_reporting() === 0) return; throw new ErrorException($errstr, 0, $errno, $errfile, $errline); } 在Bootstrap.php中初始化ErrorHandler public function _initErrorHandler(Yaf_Dispatcher $dispatcher) { $dispatcher-&gt;setErrorHandler(array(get_class($this),&apos;error_handler&apos;)); } 这样当有有程序异常时会转到ErrorController 路由和分发 简单的理解 就我的理解来说，路由分发过程的执行动作是，获取用户请求的URl，根据路由规则解析这个URL，得到module、controller、action、param、query，根据获得的module和controller去载入控制器，执行对应的action方法。插件钩子路由器也有插件钩子,就是routerStartup和routerShutdown,他们在路由解析前后分别被调用.本文档使看构建 设置路由的方法 添加配置 routes.regex4.type=&quot;regex&quot; routes.regex4.match=&quot;#^/news/([^/])/([^/])#&quot; routes.regex4.route.controller=news routes.regex4.route.action=detail routes.regex4.map.1=id routesregex4map2=sort 在Bootstapphp中添加路由配置 &lt;?php class Bootstrap extends Yaf_Bootstrap_Abstract{ public function _initRoute(Yaf_Dispatcher $dispatcher) { $router = Yaf_Dispatcher::getInstance()-&gt;getRouter(); $router-&gt;addConfig(Yaf_Registry::get(&quot;config&quot;)-&gt;routes); } } 添加接收的控制器 &lt;?php class NewsController extends Yaf_Controller_Abstract { public function init() { Yaf_Dispatcher::getInstance()-&gt;disableView(); } public function detailAction($id = 0,$sort = &apos;&apos;) { print_r($this-&gt;getRequest()-&gt;getParams()); echo &apos;News Detail:&apos;.$id.&apos;,sort:&apos;.$sort; } } ?&gt; 访问 url: yourhost/news/78/createtime 当访问这个url，yaf先根据我们的路由规则解析出默认的module,news控制器,detailAction,第一个参数id,第二个参数，sort。 我们来分析一下解析流程： YafApplication::app()&gt;bootstrap()&gt;getDispatcher&gt;dispatch(); 1.在yaf_dispatcher_route中，完成路由解析，得到module=’’，controller=news，action=detail 2.在yaf_dispatcher_fix_default中，通过其处理得到module=index，controller=news，action=detail 3.在2中完成之后，通过如果有hook机制，就会执行插件钩子：routerShutdown 4.在yaf_internal_autoload中完成自动加载类文件，application/controllers/News.php 5执行detailAction 在Bootstrapphp中配置路由规则 上面就是一个简单的通过正则的方式来设置路由的示例，我们还可以直接在Bootstrap.php添加我们的路由规则： public function _initRoute(Yaf_Dispatcher $dispatcher) { $router = Yaf_Dispatcher::getInstance()-&gt;getRouter(); $router-&gt;addConfig(Yaf_Registry::get(&quot;config&quot;)-&gt;routes); //在刚才的示例里添加上下面两行 $route = new Yaf_Route_Simple(&quot;m&quot;, &quot;c&quot;, &quot;a&quot;); $router-&gt;addRoute(&quot;simple&quot;, $route); ｝ 测试一下 我们就可以尝试用 yourhost?c=news&amp;a=detail 访问你的newsController,detailAction了。 Yaf_Route_Simple上面是Yaf_Route_Simple的一个示例 Yaf_Route_Simple是基于请求中的query string来做路由的, 在初始化一个Yaf_Route_Simple路由协议的时候, 我们需要给出3个参数, 这3个参数分别代表在query string中Module, Controller, Action的变量名，它也可以直接在配置信息里设置 routes.simple.type=&quot;simple&quot; routes.simple.controller=c routes.simple.module=m routes.simple.action=a 更多关于路由的信息可以参见官方文档：http://www.laruence.com/manual/yaf.routes.static.html]]></content>
      <categories>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Yaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaf---Session | 模板 | 模型 | Cli模式]]></title>
    <url>%2F2016%2F07%2F30%2Fyaf03%2F</url>
    <content type="text"><![CDATA[Yaf_Session是Yaf对Session的包装, 实现了Iterator, ArrayAccess, Countable接口, 方便使用.关于Yaf_Session的文档介绍：http://www.laruence.com/manual/yaf.class.session.html Session 使用示例 模板The Yaf_View_Simple class官方文档：http://www.laruence.com/manual/yaf.class.view.html Yaf_View_Simple是Yaf自带的视图引擎, 它追求性能, 所以并没有提供类似Smarty那样的多样功能, 和复杂的语法.对于Yaf_View_Simple的视图模板, 就是普通的PHP脚本, 对于通过Yaf_View_Interface::assgin的模板变量,可在视图模板中直接通过变量名使用. 使用 $this-&gt;getView()-&gt;assign()在控制器中定义变量 &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() { $mod = new UserModel(); $list = $mod-&gt;where(&apos;id&apos;,1)-&gt;get(); $this-&gt;getView()-&gt;assign(&quot;list&quot;, $list); $this-&gt;getView()-&gt;assign(&quot;title&quot;, &quot;Smarty Hello World&quot;); $this-&gt;getView()-&gt;assign(&quot;content&quot;, &quot;Hello World&quot;); } 在模板文件中使用php脚本来输出 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;?=$title;?&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?=$content;?&gt; &lt;?php foreach($list as $val):?&gt; &lt;p&gt;&lt;?=$val[&apos;username&apos;]?&gt;&lt;/p&gt; &lt;?php endforeach;?&gt; &lt;/body&gt; &lt;/html&gt; 关闭自动加载模板Yaf框架默认是开启自动加载模板的，如要关闭自动加载，可在Bootstrap.php里设置全局关闭，如： &lt;?php class Bootstrap extends Yaf_Bootstrap_Abstract { public function _initConfig(){ Yaf_Registry::set(&apos;config&apos;, Yaf_Application::app()-&gt;getConfig()); Yaf_Dispatcher::getInstance()-&gt;autoRender(FALSE); // 关闭自动加载模板 } } 单独关闭模板加载，可以需要关闭的控制器内利用Yaf_Dispatcher::getInstance()-&gt;disableView()作： &lt;?php class IndexController extends Yaf_Controller_Abstract { /** * Controller的init方法会被自动首先调用 */ public function init() { /** * 如果是Ajax请求, 则关闭HTML输出 */ if ($this-&gt;getRequest()-&gt;isXmlHttpRequest()) { Yaf_Dispatcher::getInstance()-&gt;disableView(); } } } ?&gt; 手动调用指定模板在控制器里手动调用的方式有2种： 一、调用当前$this-&gt;_module目录下的模版，下面是手动调用view/index/目录下hello.phtml模板 &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() { $this-&gt;getView()-&gt;assign(&quot;content&quot;, &quot;Hello World&quot;); $this-&gt;display(&apos;hello&apos;); } } 二、随意调用view目录下的模板，下面是调用view/test/world.phtml模板 &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() { $this-&gt;getView()-&gt;assign(&quot;content&quot;, &quot;Hello World&quot;); $this-&gt;getView()-&gt;display(&apos;test/world.phtml&apos;); } } 模型 还有不少同学问, 为什么Yaf没有ORM, 这里有俩方面的考虑:首先, Yaf并不是万能的, 它只是解决了应用中, 最基本的一个问题, 就是框架带来的额外的性能开销,然而这本部分的开销和你的应用实际的开销相比, 往往是很小的.但是, Yaf却代表着一种精神, 就是追求简单, 追求高效, 追求:”简单可依赖”, 所以Yaf专注于实现最核心的功能, 提供最稳定的实现.相比ORM, 如果要实现的很方便, 那必然会很复杂, 在当时的情况下, 实现ORM有可能会引入不稳定性第二, 也是最重要的一点是PHP已经提供了对DB的一个轻度封装的PDO, 我认为直接使用PDO, 会更加简单, 更加高效, 我不希望提供一个复杂的ORM包装, 鼓励大家去抛弃简单的PDO而使用ORM. 所以, 最初的时候, Yaf并不包含ORM.诚然, ORM可以提高开发效率, 尤其对于一些简单应用, 所以我想在后续的Yaf的版本中, 会考虑加入ORM, 但是那也绝对会是一个简单的ORM, 类似于Yaf的内建视图引擎: Yaf_View_Simple, 简单可依赖. 显然，目前yaf是没有内置的操作数据库类了，那只能自己diy了，yaf的model规则是，类名以Model为后缀，放在放置在models文件夹下面 先在application.ini配置文件里添加数据库配置信息: db.type=mysql db.host=localhost db.database=test db.username=root db.password=123 db.charset = utf8 db.log = false db.collation=utf8_unicode_ci db.prefix = 在models文件夹下面新建一个base.php文件: 载入第三方的ORM 上面只是一个简单的model实现方法，大家可以再自行完善。在一些项目中，ORM可以提高开发效率,我这里也尝试着载入lavarel框架中所使用的Eloquent ORM。loquent ORM操作介绍：http://www.golaravel.com/laravel/docs/4.2/eloquent/因为下载有点慢，我就直接从laravel5.1的包里面直接复制出的eloquent。 将文件夹放置到library下面,如下所示 在Bootstarpphp初始化eloquent &lt;?php Yaf_loader::import(&quot;/vendor/autoload.php&quot;); use Illuminate\Container\Container; use Illuminate\Database\Capsule\Manager as Capsule; class Bootstrap extends Yaf_Bootstrap_Abstract{ private $config; public function _initConfig() { $this-&gt;config = Yaf_Application::app()-&gt;getConfig(); Yaf_Registry::set(&quot;config&quot;, $this-&gt;config); } //载入数据库ORM public function _initDatabase() { $database = array( &apos;driver&apos; =&gt; $this-&gt;config-&gt;db-&gt;type, &apos;host&apos; =&gt; $this-&gt;config-&gt;db-&gt;host, &apos;database&apos; =&gt; $this-&gt;config-&gt;db-&gt;database, &apos;username&apos; =&gt; $this-&gt;config-&gt;db-&gt;username, &apos;password&apos; =&gt; $this-&gt;config-&gt;db-&gt;password, &apos;charset&apos; =&gt; $this-&gt;config-&gt;db-&gt;charset, &apos;collation&apos; =&gt; $this-&gt;config-&gt;db-&gt;collation, &apos;prefix&apos; =&gt; $this-&gt;config-&gt;db-&gt;prefix, ); $capsule = new Capsule; // 创建链接 $capsule-&gt;addConnection($database); // 设置全局静态可访问 $capsule-&gt;setAsGlobal(); // 启动Eloquent $capsule-&gt;bootEloquent(); } 在models文件夹下新建UsersModel的Users.php: &lt;?php use Illuminate\Database\Eloquent\Model as Mymodel; class UsersModel extends Mymodel{ protected $table = &apos;user&apos;; } ?&gt; 在控制器中调用： &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() { Yaf_Dispatcher::getInstance()-&gt;disableView(); $mod = new UsersModel(); $data = $mod-&gt;find(1)-&gt;toArray(); print_r($data); } 更多关于Eloquent ORM的操作介绍可移步： http://www.golaravel.com/laravel/docs/4.2/eloquent/ 命令行模式官方文档地址：http://yaf.laruence.com/manual/yaf.incli.times.html 感觉文档写得有点简单，不好理解，这里聊下我是怎么用的yaf命令行。 方法一 在yaf中用到命令行大多是为了跑Crontab，首先，为了更好的与web区分(配置文件,argc、argv判断等等).重新创建个入口文件是比较好的做法 &lt;?php define(&quot;APP_PATH&quot;, realpath(dirname(__FILE__))); $app = new Yaf_Application(APP_PATH . &quot;/conf/application.ini&quot;); $app-&gt;getDispatcher()-&gt;dispatch(new Yaf_Request_Simple()); 然后再新建一个接收命令和操作的控制器Crontab.php: &lt;?php class CrontabController extends Yaf_Controller_Abstract { public function init(){ Yaf_Dispatcher::getInstance()-&gt;disableView(); } public function indexAction($username = &apos;&apos;){ //to do a crontab echo &apos;we get the name is : &apos;.$username; } } ?&gt; 接下来，我们在命令行中调用。在命令行中切换到你的项目目录，就是cli.php所在目录，然后输入如下命令：php cli.php request_uri=&quot;/crontab/index&quot;是不是在命令行看到了输出的字符串。request_uri=&quot;/crontab/index&quot; 中的路径便是Controller的路由路径.在例子里指向/controllers/Crontab.php 中的 indexAction() 方法二 还有一种方法，通过Yaf_Application::execute(..)去实现。 先看一下这个函数的定义： public void Yaf_Application::execute ( callable $entry , string $... ) This method is typically used to run Yaf_Application in a crontab work. Make the crontab work can also use the autoloader and Bootstrap mechanism. 第一参数需要定义一个回调函数,也可以是一个类中的某个函数。 示例：$application-&gt;execute(“main”, $argc, $argv);或 $application-&gt;execute(array(“Class”,”Method”), $argc, $argv); 后面的参数为一个可变列表，值为你希望传入的参数。如些，我们将刚才新建的cli.php文件改写成： &lt;?php define(&quot;APP_PATH&quot;, realpath(dirname(__FILE__))); $app = new Yaf_Application(APP_PATH . &quot;/conf/application.ini&quot;); $app-&gt;bootstrap()-&gt;execute(array(&apos;CrontabController&apos;,&apos;indexAction&apos;),&apos;wulei&apos;); 其中如果你需要用bootstrap的初始化的，可以保留，如果不需要的话，也可以把bootstrap去掉。]]></content>
      <categories>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Yaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaf---加载规则插件使用]]></title>
    <url>%2F2016%2F07%2F29%2Fyaf02%2F</url>
    <content type="text"><![CDATA[Yaf在自启动的时候, 会通过SPL注册一个自己的Autoloader, 出于性能的考虑, 对于框架相关的MVC类, Yaf Autoloader只以目录映射的方式尝试一次. 类型 后缀 映射路径 控制器 Controller 默认模块下为{项目路径}/controllers/, 否则为{项目路径}/modules/{模块名}/controllers/ 数据模型 Model {项目路径}/models/ 插件 Plugin {项目路径}/plugins/ 一个简单的自我理解&lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() {//默认Action $mod = new TserModel(); //自动加载model下面的test.php文件 $mod-&gt;query(); //调用TestModel里的query方法 $user = new UserPlugin(); //自动加载plugins下面的user.php文件 $this-&gt;getView()-&gt;assign(&quot;title&quot;, &quot;Hello Yaf&quot;); $this-&gt;getView()-&gt;assign(&quot;content&quot;, &quot;Hello Yaf Content&quot;); } 类的自动加载规则而类的加载规则, 都是一样的: Yaf规定类名中必须包含路径信息, 也就是以下划线”_”分割的目录信息. Yaf将依照类名中的目录信息, 完成自动加载. 如下的例子, 在没有申明本地类的情况下: public function indexAction() { $upload = new upload_aliyun(); //这个就会按下划线分割目录来寻找文件，所以他会寻找 \library\upload\aliyun.php } 先这么简单理解，还有一个registerLocalNamespace的内容，后续再来说一说，怕混了。 手动载入Yaf_Loader::import 导入一个PHP文件, 因为Yaf_Loader::import只是专注于一次包含, 所以要比传统的require_once性能好一些示例： &lt;?php //绝对路径 Yaf_Loader::import(“/usr/local/foo.php); //相对路径, 会在APPLICATION_PATH.”/library”下加载 Yaf_loader::import(“plugins/User.php”); ?&gt; 使用BoostrapBootstrap, 也叫做引导程序. 它是Yaf提供的一个全局配置的入口, 在Bootstrap中, 你可以做很多全局自定义的工作. 使用Bootstrap 在一个Yaf_Application被实例化之后, 运行(Yaf_Application::run)之前, 可选的我们可以运行Yaf_Application::bootstrap改写index.php文件如下： &lt;?php define(&quot;APP_PATH&quot;, realpath(dirname(__FILE__))); $app = new Yaf_Application(APP_PATH . &quot;/conf/application.ini&quot;); $app-&gt;bootstrap()-&gt;run(); 当bootstrap被调用的时刻, Yaf_Application就会默认的在APPLICATION_PATH下, 寻找Bootstrap.php,而这个文件中, 必须定义一个Bootstrap类, 而这个类也必须继承自Yaf_Bootstrap_Abstract.实例化成功之后, 所有在Bootstrap类中定义的, 以_init开头的方法, 都会被依次调用, 而这些方法都可以接受一个Yaf_Dispatcher实例作为参数.也可以通过在配置文件中修改application.bootstrap来变更Bootstrap类的位置. 简单的示例Bootstrap.php &lt;?php class Bootstrap extends Yaf_Bootstrap_Abstract { public function _initConfig(){ $config = Yaf_Application::app()-&gt;getConfig(); Yaf_Registry::set(&quot;config&quot;, $config); } public function _initDefaultName(Yaf_Dispatcher $dispatcher) { $dispatcher-&gt;setDefaultModule(&quot;Index&quot;)-&gt;setDefaultController(&quot;Index&quot;)-&gt;setDefaultAction(&quot;index&quot;); } } 插件使用Yaf支持用户定义插件来扩展Yaf的功能, 这些插件都是一些类. 它们都必须继承自Yaf_Plugin_Abstract. 插件要发挥功效, 也必须现实的在Yaf中进行注册, 然后在适当的实际, Yaf就会调用它. Yaf 支持的Hook 名称 触发时机 说明 routerStartup 在路由之前触发 这个是7个事件中, 最早的一个. 但是一些全局自定的工作, 还是应该放在Bootstrap中去完成 routerShutdown 路由结束之后触发 此时路由一定正确完成, 否则这个事件不会触发 dispatchLoopStartup 分发循环开始之前被触发 preDispatch 分发之前触发 如果在一个请求处理过程中, 发生了forward, 则这个事件会被触发多次 postDispatch 分发结束之后触发 此时动作已经执行结束, 视图也已经渲染完成. 和preDispatch类似, 此事件也可能触发多次 dispatchLoopShutdown 分发循环结束之后触发 此时表示所有的业务逻辑都已经运行完成, 但是响应还没有发送 定义插件 插件类是用户编写的, 但是它需要继承自Yaf_Plugin_Abstract. 对于插件来说, 上一节提到的7个Hook, 它不需要全部关心, 它只需要在插件类中定义和上面事件同名的方法, 那么这个方法就会在该事件触发的时候被调用.而插件方法, 可以接受俩个参数, Yaf_Request_Abstract实例和Yaf_Response_Abstract实例. 一个插件类例子如下: plugins/User.php &lt;?php class UserPlugin extends Yaf_Plugin_Abstract { public function routerStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $respons } public function routerShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $respo } } 注册插件 插件要生效, 还需要向Yaf_Dispatcher注册, 那么一般的插件的注册都会放在Bootstra中进行. 一个注册插件的例子如下: &lt;?php class Bootstrap extends Yaf_Bootstrap_Abstract{ public function _initPlugin(Yaf_Dispatcher $dispatcher) { $user = new UserPlugin(); $dispatcher-&gt;registerPlugin($user); } } 目录 一般的, 插件应该放置在APPLICATION_PATH下的plugins目录, 这样在自动加载的时候, 加载器通过类名,发现这是个插件类, 就会在这个目录下查找.当然, 插件也可以放在任何你想防止的地方, 只要你能把这个类加载进来就可以 获取参数Yaf_Request_Http 代表了一个实际的Http请求, 一般的不用自己实例化它, Yaf_Application在run以后会自动根据当前请求实例它，在控制器内可以使用$this-&gt;getRequest()来获取请求信息。更多Yaf_Request_Http类的内容可参见文档： http://www.laruence.com/manual/yaf.class.request.html#yaf.class.request.http 使用示例 &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction($name=&apos;&apos;, $value=&apos;&apos;) { print_r($this-&gt;getRequest()-&gt;getQuery()); } 扩展 Yaf_Request_Http，比如加上过滤，数据处理等。先在library定义一个request的类,再在Bootstrap.php里设置Request文件示例：library/Request.php &lt;?php class Bootstrap extends Yaf_Bootstrap_Abstract{ public function _initRequest(Yaf_Dispatcher $dispatcher) { $dispatcher-&gt;setRequest(new Request()); } } 然后在控制器中可以使用$this-&gt;getRequest()-&gt;getQuery()来获取参数 &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() { print_r($this-&gt;getRequest()-&gt;getQuery()); } 关于更多的该类的使用方法，可以参考：http://www.laruence.com/manual/yaf.class.request.html]]></content>
      <categories>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Yaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaf---写在前面]]></title>
    <url>%2F2016%2F07%2F28%2Fyaf01%2F</url>
    <content type="text"><![CDATA[Yaf有着和Zend Framework相似的API, 相似的理念, 而同时又保持着对Bingo的兼容, 以此来提高开发效率, 规范开发习惯. 本着对性能的追求, Yaf把框架中不易变的部分抽象出来,采用PHP扩展实现(c语言),以此来保证性能.在作者自己做的简单测试中, Yaf和原生的PHP在同样功能下, 性能损失小于10%, 而和ZendFramework的对比中, Yaf的性能是Zend Framework的50-60倍. 天下武功无坚不破，唯快不破 用C语言开发的PHP框架, 相比原生的PHP, 几乎不会带来额外的性能开销. 所有的框架类, 不需要编译, 在PHP启动的时候加载, 并常驻内存. 更短的内存周转周期, 提高内存利用率, 降低内存占用率. 灵巧的自动加载. 支持全局和局部两种加载规则, 方便类库共享. 高性能的视图引擎. 高度灵活可扩展的框架, 支持自定义视图引擎, 支持插件, 支持自定义路由等等. 内建多种路由, 可以兼容目前常见的各种路由协议. 强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失. 在框架本身,对危险的操作习惯做了禁止. 更快的执行速度, 更少的内存占用 Yaf的安装 WindowsYaf只支持PHP5.2及以上的版本Yaf需要SPL的支持. SPL在PHP5中是默认启用的扩展模块Yaf需要PCRE的支持. PCRE在PHP5中是默认启用的扩展模块在 Windows 系统下安装PHP 5.2+ 打开yaf在php官网上的目录：http://pecl.php.net/package/yaf 目前yaf的最新版为3.0.0,仅支付php7,建议选择2.3.5版本 我这里选择2.3.5后面的win图标+DLL字样的链接，进入页面下载php_yaf.dll 在打开的页面根据自己的环境来选择对应的版本，我这里选择的是php5.6 Thread Safe (TS)x86(php5.6版本 安全线程 32位操作系统) 点击后自动下载了一个压缩包：php_yaf-2.3.5-5.6-ts-vc11-x86.zip 把压缩包中的php_yaf.dll复制出来，打到你的php目录，打开目录下的ext文件夹，粘贴进去 再打开您的PHP配置文件php.ini，加入 ‘extension=php_yaf.dll’,重启web服务器,就OK了 Yaf的安装 Linux下载Yaf的最新版本, 解压缩以后, 进入Yaf的源码目录, 依次执行(其中PHP_BIN是PHP的bin目录): cd /usr/local/src#进入软件包存放目录tar zxvf yaf-2.3.5.tgz#解压cd yaf-2.3.5#进入安装目录/usr/local/php/bin/phpize#用phpize生成configure配置文件./configure --with-php-config=/usr/local/php/bin/php-config #配置makemake install安装完成之后，出现下面的安装路径/usr/local/php/lib/php/extensions/no-debug-non-zts-20100525/配置php支持vim /usr/local/php/etc/php.ini #编辑配置文件，在最后一行添加以下内容extension=&quot;yaf.so&quot;:wq! #保存退出 重启服务sudo service nginx restartsudo /etc/init.d/php-fpm restart查看php -m 看到神秘的yaf 就说明安装成功了 Yaf_Request_Abstract的getPost, getQuery等方法, 并没有对应的setter方法. 并且这些方法是直接从PHP内部的$_POST, $_GET等大变量的原身变量只读的查询值, 所以就有一个问题:通过在PHP脚本中对这些变量的修改, 并不能反映到 getPost/getQuery 等方法上 yaf 的常量 常量(启用命名空间后的常量名) 说明 YAF_VERSION(Yaf\VERSION) Yaf框架的三位版本信息 YAF_ENVIRON(Yaf\ENVIRON) Yaf的环境常量, 指明了要读取的配置的节, 默认的是product YAF_ERR_DISPATCH_FAILED(Yaf\ERR\DISPATCH_FAILED) Yaf的错误代码常量, 表示分发失败, 值为514 YAF_ERR_NOTFOUND_MODULE(Yaf\ERR\NOTFOUD\MODULE) Yaf的错误代码常量, 表示找不到指定的模块, 值为515 YAF_ERR_NOTFOUND_CONTROLLER(Yaf\ERR\NOTFOUD\CONTROLLER) Yaf的错误代码常量, 表示找不到指定的Controller, 值为516 YAF_ERR_NOTFOUND_ACTION(Yaf\ERR\NOTFOUD\ACTION) Yaf的错误代码常量, 表示找不到指定的Action, 值为517 YAF_ERR_NOTFOUND_VIEW(Yaf\ERR\NOTFOUD\VIEW) Yaf的错误代码常量, 表示找不到指定的视图文件, 值为518 YAF_ERR_CALL_FAILED(Yaf\ERR\CALL_FAILED) Yaf的错误代码常量, 表示调用失败, 值为519 YAF_ERR_AUTOLOAD_FAILED(Yaf\ERR\AUTOLOAD_FAILED) Yaf的错误代码常量, 表示自动加载类失败, 值为520 YAF_ERR_TYPE_ERROR(Yaf\ERR\TYPE_ERROR) Yaf的错误代码常量, 表示关键逻辑的参数错误, 值为521 yaf 的配置项 选项名称 默认值 可修改范围 更新记录 yaf.environ product PHP_INI_ALL 环境名称, 当用INI作为Yaf的配置文件时, 这个指明了Yaf将要在INI配置中读取的节的名字 yaf.library NULL PHP_INI_ALL 全局类库的目录路径 yaf.cache_config 0 PHP_INI_SYSTEM 是否缓存配置文件(只针对INI配置文件生效), 打开此选项可在复杂配置的情况下提高性能 yaf.name_suffix 1 PHP_INI_ALL 在处理Controller, Action, Plugin, Model的时候, 类名中关键信息是否是后缀式, 比如UserModel, 而在前缀模式下则是ModelUser yaf.name_separator “” PHP_INI_ALL 在处理Controller, Action, Plugin, Model的时候, 前缀和名字之间的分隔符, 默认为空, 也就是UserPlugin, 加入设置为”_”, 则判断的依据就会变成:”User_Plugin”, 这个主要是为了兼容ST已有的命名规范 yaf.forward_limit 5 PHP_INI_ALL forward最大嵌套深度 yaf.use_namespace 0 PHP_INI_SYSTEM 开启的情况下, Yaf将会使用命名空间方式注册自己的类, 比如Yaf_Application将会变成Yaf\Application yaf.use_spl_autoload 0 PHP_INI_ALL 开启的情况下, Yaf在加载不成功的情况下, 会继续让PHP的自动加载函数加载, 从性能考虑, 除非特殊情况, 否则保持这个选项关闭 在开启yaf.cache_config的情况下, Yaf会使用INI文件路径作为Key, 这就有一个陷阱, 就是如果在一台服务器上同时运行俩个应用, 那么它们必须不能使用同一个路径名下的INI配置文件, 否则就会出现Application Path混乱的问题. 所以, 尽量不要使用相对路径. 快速开始├──public │ ├── index.php 入口文件 │ ├── .htaccess 重写规则 │ ├── css │ ├── img │ ├── js ├──conf │ ├── application.ini 配置文件 ├──application │ ├── Controllers │ ├── Index.php 默认控制器 │ ├── views │ ├── Index 控制器名 │ ├── index.phtml 默认视图 ├──modules 其他模块 ├──library 本地类库 ├──models model目录 ├──plugins 插件目录 入口文件入口文件是所有请求的入口, 一般都借助于rewrite规则, 把所有的请求都重定向到这个入口文件. 一个经典的入口文件public/index.php &lt;?php define(&quot;APP_PATH&quot;, realpath(dirname(__FILE__) . &apos;/../&apos;)); /* 指向public的上一级 */ $app = new Yaf_Application(APP_PATH . &quot;/conf/application.ini&quot;); $app-&gt;run(); 重写规则除非我们使用基于query string的路由协议(Yaf_Route_Simple, Yaf_Route_Supervar), 否则我们就需要使用WebServer提供的Rewrite规则, 把所有这个应用的请求, 都定向到上面提到的入口文件. Apache的Rewrite (httpd.conf) #.htaccess, 当然也可以写在httpd.conf RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule .* index.php Nginx的Rewrite (nginx.conf) server { listen ****; server_name domain.com; root document_root; index index.php index.html index.htm; if (!-e $request_filename) { rewrite ^/(.*) /index.php/$1 last; } } Lighttpd的Rewrite (lighttpd.conf) $HTTP[&quot;host&quot;] =~ &quot;(www.)?domain.com$&quot; { url.rewrite = ( &quot;^/(.+)/?$&quot; =&gt; &quot;/index.php/$1&quot;, ) } SAE的Rewrite (config.yaml) name: your_app_name version: 1 handle: - rewrite: if(!is_dir() &amp;&amp; !is_file() &amp;&amp; path ~ &quot;^(.*)$&quot; ) goto &quot;/index.php&quot; [注意] 注意每种Server要启用Rewrite都需要特别设置, 如果对此有疑问.. RTFM配置文件 在Yaf中, 配置文件支持继承, 支持分节. 并对PHP的常量进行支持. 你不用担心配置文件太大造成解析性能问题, 因为Yaf会在第一个运行的时候载入配置文件, 把格式化后的内容保持在内存中. 直到配置文件有了修改, 才会再次载入. 一个简单的配置文件application/conf/application.ini [product] ;支持直接写PHP中的已定义常量 application.directory=APP_PATH &quot;/application/&quot; 控制器 在Yaf中, 默认的模块/控制器/动作, 都是以Index命名的, 当然,这是可通过配置文件修改的.对于默认模块, 控制器的目录是在application目录下的controllers目录下, Action的命名规则是”名字+Action” 默认控制器application/controllers/Index.php &lt;?php class IndexController extends Yaf_Controller_Abstract { public function indexAction() {//默认Action $this-&gt;getView()-&gt;assign(&quot;content&quot;, &quot;Hello World&quot;); } } ?&gt; 视图文件 Yaf支持简单的视图引擎, 并且支持用户自定义自己的视图引擎, 比如Smarty.对于默认模块, 视图文件的路径是在application目录下的views目录中以小写的action名的目录中. 一个默认Action的视图application/views/index/index.phtml &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php echo $content;?&gt; &lt;/body&gt; &lt;/html&gt; 运行在浏览器输入 http://www.yourhostname.com/application/index.php 看到了Hello World输出吧?]]></content>
      <categories>
        <category>Frame</category>
      </categories>
      <tags>
        <tag>Yaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见状态码]]></title>
    <url>%2F2016%2F07%2F07%2FHTTPcode%2F</url>
    <content type="text"><![CDATA[HTTP 常用状态码 拿出来 用的时候看一看 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议 200 OK 一切正常，对GET和POST请求的应答文档跟在后面 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取 307 Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。 400 Bad Request 请求出现语法错误。 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。 403 Forbidden 资源不可用。 404 Not Found 无法找到指定位置的资源 405 Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。 412 Precondition Failed 请求头中指定的一些前提条件失败 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头 414 Request URI Too Long URI太长 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>intellectual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子选大王算法]]></title>
    <url>%2F2016%2F06%2F05%2FmonkeyKing%2F</url>
    <content type="text"><![CDATA[有M个monkey ，转成一圈，第一个开始数数，数到第N个出圈，下一个再从1开始数，再数到第N个出圈，直到圈里只剩最后一个就是大王 【单项循环数据链表】 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php class MonkeyKing&#123; var $next; var $name; public function __construct($name) &#123; $this-&gt;name = $name; &#125; public static function whoIsKing($count, $num) &#123; /************* 构造单向循环链表 ******************/ // 构造单向循环链表 $current = $first = new MonkeyKing(1); for($i=2; $i&lt;=$count; $i++) &#123; $current-&gt;next = new MonkeyKing($i); $current = $current-&gt;next; &#125; // 最后一个指向第一个 $current-&gt;next = $first; // 指向第一个 $current = $first; /*************** 开始数数 *********************/ // 定义一个数字 $cn = 1; while($current !== $current-&gt;next) &#123; $cn++; // 数数 if($cn == $num) &#123; $current-&gt;next = $current-&gt;next-&gt;next; $cn = 1; &#125; $current = $current-&gt;next; &#125; // 返回猴子王的名字 return $current-&gt;name; &#125;&#125;// 共10个猴子每3个出圈echo MonkeyKing::whoIsKing(10,3);]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 单例模式]]></title>
    <url>%2F2016%2F05%2F10%2Fphpsingerl%2F</url>
    <content type="text"><![CDATA[数学与逻辑学中，singleton定义为“有且仅有一个元素的集合”在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例，节省数据库开销 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问/** * singleton Pattern 单例设计模式 3私1公 */ class DB &#123; private static $_instance;//保存类实例的私有静态成员变量 //定义一个私有的构造函数，确保单例类不能通过new关键字实例化，只能被其自身实例化 private final function __construct()//fai nuo最终 的 也就是后面的子类不能覆盖此方法 &#123; echo 'test __construct'; /* final -- 用于类、方法前。 final类 -- 不可被继承。 final方法 -- 不可被覆盖。 */ &#125; //定义私有的__clone()方法，确保单例类不能被复制或克隆 private function __clone() &#123;&#125; public static function getInstance() &#123; //检测类是否被实例化 if (!(self::$_instance instanceof self)) //in s tens 奥复 &#123; //在类里调用类的属性 要加$ //（1）判断一个对象是否是某个类的实例， //（2）判断一个对象是否实现了某个接口。 self::$_instance = new DB(); &#125; return self::$_instance; &#125;&#125;//调用单例类DB::getInstance();$db1=DB::getInstance();$db2=DB::getInstance();var_dump($db1);var_dump($db2);&lt;?php/** * singleton Pattern 单例设计模式 3私1公 */ class DB &#123; private static $_instance;//保存类实例的私有静态成员变量 //定义一个私有的构造函数，确保单例类不能通过new关键字实例化，只能被其自身实例化 private final function __construct()//fai nuo最终 的 也就是后面的子类不能覆盖此方法 &#123; echo 'test __construct'; &#125; //定义私有的__clone()方法，确保单例类不能被复制或克隆 private function __clone() &#123;&#125; public static function getInstance() &#123; //检测类是否被实例化 if (!(self::$_instance instanceof self)) //in s tens 奥复 &#123; //在类里调用类的属性 要加$ //（1）判断一个对象是否是某个类的实例，（2）判断一个对象是否实现了某个接口。 self::$_instance = new DB(); &#125; return self::$_instance; &#125;&#125;//调用单例类DB::getInstance();$db1=DB::getInstance();$db2=DB::getInstance();var_dump($db1);var_dump($db2);]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP plant]]></title>
    <url>%2F2016%2F05%2F07%2Fphp%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[顾名思义，工厂是可以加工零件的，PHP程序中的工厂模式也有相同的功能，可以方便的使用一个静态的工厂方法来实例化某一个类，那么这样做的好处是什么呢？初学PHP的设计模式，实例化一个类会给它一些参数以便在其构析的时候可以根据不同的参数反馈出我们需要的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960举例说明，以下是一个User类，非常简单：/*** factory pattern 工厂模式*/ interface abstracted &#123; public function realCreate(); &#125; //女人类 class Woman &#123; public function action() &#123; echo '这是女人'; &#125; &#125; //男人类 class Man &#123; public function action() &#123; echo '这是男人'; &#125; &#125; //创建女人 class WomanCreator implements abstracted &#123; public $chromosome;//染色体 public function realCreate()&#123; if ($this-&gt;chromosome == "xx") &#123; return new Woman(); &#125; &#125; &#125; //创建男人 class ManCreator implements abstracted &#123; public $chromosome; public function realCreate()&#123; if ($this-&gt;chromosome == "xy" || $this-&gt;chromosome == "xyy") &#123; return new Man(); &#125; &#125; &#125; //人类工厂 class PersonFactory &#123; public function create($what) &#123; $create = $what."Creator"; //womanCreator return new $create(); &#125; &#125; $create = new PersonFactory(); $instance = $create-&gt;create('woman'); $instance-&gt;chromosome = "xx"; $instance-&gt;realCreate()-&gt;action();?&gt;]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 画图形 N行N列]]></title>
    <url>%2F2016%2F05%2F05%2Fphp%E7%94%BB%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[写一个函数需要一个参数，根据这个参数输出一个图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?php/* 算法二、写一个函数需要一个参数，根据这个参数输出一个图形，比如：输入4： 4 5 6 7 15 16 17 8 14 19 18 9 13 12 11 10比如：输入3：3 4 510 11 69 8 7*//*3*3+3-1 --&gt; 114*4+4-1 --&gt; 19$arr = [ [0,0,0], [0,0,0], [0,0,0],]; x y$arr[0][0] = 3;$arr[0][1] = 4;向右移动y++向左移动y--左下移动x++移动的条件： 1. y++ &lt; $num 没出框 2. $arr[$x][$y+1] == 0 【没被占用】$arr = [ [3,4,5], [10,11,6], [9,8,7],];*/function jz($num)&#123; /************************* 先构造二维数组 ********************/ for($i=0; $i&lt;$num; $i++) &#123; for($j=0; $j&lt;$num; $j++) &#123; $map[$i][$j] = 0; &#125; &#125; /************************* 循环往数组中放 ********************/ // 计算最后一个数 $end = $num * $num + $num - 1; // 初始化要放的位置 $x = $y = 0; // 初始化方向 // r:右 l：左 t：上 b：下 $d = 'r'; // 先把第一个数放进去 $map[$x][$y] = $num; // 循环放从第二个数开始放 for($i=$num+1; $i&lt;=$end; $i++) &#123; if($d == 'r') &#123; if($y+1 &lt; $num &amp;&amp; $map[$x][$y+1] == 0) $y++; // 修改坐标 else $d = 'b'; &#125; if($d == 'b') &#123; if($x+1 &lt; $num &amp;&amp; $map[$x+1][$y] == 0) $x++; // 修改坐标 else $d = 'l'; &#125; if($d == 'l') &#123; if($y-1 &gt;= 0 &amp;&amp; $map[$x][$y-1] == 0) $y--; // 修改坐标 else $d = 't'; &#125; if($d == 't') &#123; if($x-1 &gt;= 0 &amp;&amp; $map[$x-1][$y] == 0) $x--; // 修改坐标 else &#123; $d = 'r'; $y++; // 修改坐标 &#125; &#125; // 把数进来 $map[$x][$y] = $i; &#125; /***************************** 画出图形 **************************/ $table = '&lt;table border="1"&gt;'; for($i=0; $i&lt;$num; $i++) &#123; $table .= '&lt;tr&gt;'; for($j=0; $j&lt;$num; $j++) &#123; $table .= '&lt;td&gt;'; $table .= $map[$i][$j]; $table .= '&lt;/td&gt;'; &#125; $table .= '&lt;/tr&gt;'; &#125; $table .= '&lt;/table&gt;'; echo $table;&#125;jz(20);?&gt;]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的CSS样式]]></title>
    <url>%2F2016%2F02%2F27%2FOOCSS%2F</url>
    <content type="text"><![CDATA[OOCSS:面向对象的CSS样式，通过对CSS样式的合理规范，重复使用，达到代码的精简，便于换肤。 作用：12341. 加强代码复用以便方便维护1. 减少CSS体积1. 提升渲染效率1. 组件库思想、栅格布局可共用、减少选择器、方便扩展 注意事项：123456789101112131. 不要直接定义子节点，应把共性声明放到父类.mod .inner&#123;&#125; //1. 结构和皮肤相分离1. 容器和内容相分离1. 抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面1. 往你想要扩展的对象本身添加Class，而不是他的父节点1. 对象应保持独立性1. 避免使用ID选择器，权重太高，无法重用1. 避免位置相关的样式1. 保证选择器相同的权重1. 类名：简短、清晰、语义化、OOCSS的名字并不影响HTML语义化 拓展OOCSS Reset 优点：样式初始化设置非常全面缺点：设置了部分多余的设置，border Normalize 优点：缺点：有些默认的没有设置 Neat.css 优点： 解决Bug，低级浏览器常见Bug 统一效果，但不盲目追求重置为0 向后兼容 考虑响应式 考虑移动设备 缺点：]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax学习计划]]></title>
    <url>%2F2016%2F01%2F27%2FAjax%2F</url>
    <content type="text"><![CDATA[AJAX：Asynchronous Javascript And XML（异步JavaScript和XML）。是指一种创建交互式网页应用的网页开发技术。 AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 Ajax介绍特点：12什么是服务器：搭建简单的本地服务器软件Wamp、XAMPP，提供简单的用户服务，读取数据。 使用Ajax12345基础：请求并显示静态TXT、json文件字符集编码：UTF-8、GB2312，使用相同的编码。缓存：chrome下的缓存还不是很严重，IE下的缓存比较严重，除非关闭浏览器。缓存的工作原理：通过URL进行缓存的。通常可以使用URL?t= + new Date().getTime() 123456789101112window.onload = function ()&#123; var oBtn = document.getElementById(&apos;Btn1&apos;); oBtn.onclick = function ()&#123; ajax(&apos;aa.txt?t=&apos; + new Date().getTime(), function(str)&#123; alert(str); &#125;,function()&#123; alert(&apos;失败&apos;); &#125;); &#125;&#125; 通过Ajax读取的都是字符串1234567891011121314通过eval()将文件内容解析成JS可以识别的内容window.onload = function ()&#123; var oBtn = document.getElementById(&apos;Btn1&apos;); oBtn.onclick = function ()&#123; ajax(&apos;aa.txt?t=&apos; + new Date().getTime(), function(str)&#123; var SA = eval(str); alert(SA[1]); &#125;,function()&#123; alert(&apos;失败&apos;); &#125;); &#125;&#125; 读取Json文件123456789101112131415161718192021window.onload = function ()&#123; var oBtn = document.getElementById(&apos;Btn1&apos;); var oUls = document.getElementById(&apos;ul1&apos;); oBtn.onclick = function ()&#123; ajax(&apos;aa.txt?t=&apos; + new Date().getTime(), function(str)&#123; var SA = eval(str); for(var i=0;i&lt;SA.length;i++)&#123; var oLi = document.createElement(&apos;li&apos;); oLi.innnerHTML=&apos;用户名：&lt;strong&gt;&apos; + SA[i].name +&apos;&lt;/strong&gt;密码：&lt;span&gt;&apos; + SA[i].pass + &apos;&lt;/span&gt;&apos;; //添加到Ul里 oUl.appenChild(oLi); &#125; alert(SA[1]); &#125;,function()&#123; alert(&apos;失败&apos;); &#125;); &#125;&#125; 123456789HTTP请求的方法GET：用于获取数据（如：浏览贴子）POST：用于上传数据（如：用户注册）区别：get是在URL里传送数据：安全性低、容量有限（2000字符），有缓存，适合请求信息post是通过HTTP请求，安全性好一点，无缓存，适合传递信息安全的方式使用HTTPS。GET方式：?name=word&amp;password=password Ajax进阶创建Ajax1234IE6var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);var oAjax = new XMLHttpRequest(); 1234567注意：//使用没有定义的变量——报错alert(a);//使用没有定义的属性——undefinedalert(window.a); 1234567function ()&#123; if(window.XMLHttpRequest)&#123; var oAjax = new XMLHttpRequest(); &#125;else&#123; var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;&#125; 连接服务器1234567891011121314open（方法，连接的文件名，同步/async异步true）ajxa其实都是异步的open(method,url,async);oAjax.opan(&apos;GET&apos;,&apos;a.text?=t&apos;+new Date().getTime(),true);同步和异步的区别?同步：（一次加载）浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,j进行下一步操作。异步：（同时加载）浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。（待完善） 发送请求12oAjax.send();send(string); 接收返回12345678910oAjax.onreadystatechange = function()&#123; //浏览器和服务器，进行到哪一步了 if(oAjax.readyState==4)&#123; if(oAjax.status==200)&#123; alert(&apos;成功：&apos;+oAjax.status); &#125;else&#123; alert(&apos;失败：&apos;+oAjax.status); &#125; &#125;&#125; 123450 （未初始化）1 （载入）2 （载入完成）send()方法完成，已接收全部信息3 （解析）正在解析响应4 （完成）完成但不代表成功 123456Ajax Status请求状态200 成功301304404 1234IE6var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);var oAjax = new XMLHttpRequest(); 1234567891011121314151617181920212223242526272829封装函数function ajax(url,fnSucc,fnFaild)&#123; if(window.XMLHttpRequest)&#123; var oAjax = new XMLHttpRequest(); &#125;else&#123; var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; oAjax.opan(&apos;GET&apos;,&apos;url?=t&apos;+new Date().getTime(),true); oAjax.send(); oAjax.onreadystatechange = function()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status==200)&#123; fnSucc(oAjax.responseText); &#125;else&#123; if(fnFaild)&#123; fnFaild(oAjax.status); &#125; &#125; &#125; &#125;&#125;ajax(&apos;a.txt&apos;,function(str)&#123; alert(str);&#125;) 12345678910111213141516171819202122232425262728293031封装函数function ajax(url,data,fnSucc,fnFaild)&#123; if(window.XMLHttpRequest)&#123; var oAjax = new XMLHttpRequest(); &#125;else&#123; var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; oAjax.opan(&apos;POST&apos;,&apos;url&apos;,true); oAjax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); oAjax.send(data); oAjax.onreadystatechange = function()&#123; if(oAjax.readyState==4)&#123; if(oAjax.status==200)&#123; fnSucc(oAjax.responseText); &#125;else&#123; if(fnFaild)&#123; fnFaild(oAjax.status); &#125; &#125; &#125; &#125;&#125;ajax(&apos;a.txt&apos;,&apos;name=&apos; + document.getElementById(&quot;staffName&quot;).value + &apos;&amp;number=&apos; + document.getElementById(&quot;staffNumber&quot;).value + &apos;&amp;sex=&apos; + document.getElementById(&quot;staffSex&quot;).value + &apos;&amp;job=&apos; + document.getElementById(&quot;staffJob&quot;).value,function(str)&#123; alert(str);&#125;) Ajax数据1XML、Json：同等数据量，XML更大]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax Status请求状态]]></title>
    <url>%2F2016%2F01%2F19%2FAjaxStatus%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍了各类Http请求状态(status)及其含义。 需要的朋友可以过来参考下，希望对大家有所帮助。Web服务器响应浏览器或其他客户程序的请求时，其应答一般由以下几个部分组成：一个状态行，几个应答头，一个空行，内容文档。下面是一个最简单的应答 ：状态行包含HTTP版本、状态代码、与状态代码对应的简短说明信息。 在大多数情况下，除了Content-Type之外的所有应答头都是可选的。但Content-Type是必需的，它描述的是后面文档的MIME类型。虽然大多数应答都包含一个文档，但也有一些不包含，例如对HEAD请求的应答永远不会附带文档。有许多状态代码实际上用来标识一次失败的请求，这些应答也不包含文档（或只包含一个简短的错误信息说明）。当用户试图通过 HTTP 访问一台正在运行 Internet 信息服务 (IIS) 的服务器上的内容时，IIS 返回一个表示该请求的状态的数字代码。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。 1xx - 信息提示123这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 2xx - 成功12345678这类状态代码表明服务器成功地接受了客户端请求。200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 - Created 服务器已经创建了文档，Location头给出了它的URL。 202 - Accepted 已经接受请求，但处理尚未完成。 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（HTTP 1.1新）。204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 - Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 3xx - 重定向12345678客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。300 - Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 - Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 - Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user （缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 - See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 - Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 - Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 - Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新） 4xx - 客户端错误1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。400 - Bad Request 请求出现语法错误。 401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。IIS 定义了许多不同的 401 错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示：401.1 - 登录失败。401.2 - 服务器配置导致登录失败。401.3 - 由于 ACL 对资源的限制而未获得授权。401.4 - 筛选器授权失败。401.5 - ISAPI/CGI 应用程序授权失败。401.7 – 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。禁止访问：IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：403.1 - 执行访问被禁止。403.2 - 读访问被禁止。403.3 - 写访问被禁止。403.4 - 要求 SSL。403.5 - 要求 SSL 128。403.6 - IP 地址被拒绝。403.7 - 要求客户端证书。403.8 - 站点访问被拒绝。403.9 - 用户数过多。403.10 - 配置无效。403.11 - 密码更改。403.12 - 拒绝访问映射表。403.13 - 客户端证书被吊销。403.14 - 拒绝目录列表。403.15 - 超出客户端访问许可。403.16 - 客户端证书不受信任或无效。403.17 - 客户端证书已过期或尚未生效。403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答。404.0 -（无） – 没有找到文件或目录。404.1 - 无法在所请求的端口上访问 Web 站点。404.2 - Web 服务扩展锁定策略阻止本请求。404.3 - MIME 映射策略阻止本请求。405 - Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用，用来访问本页面的 HTTP 谓词不被允许（方法不被允许）（HTTP 1.1新） 406 - Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容，客户端浏览器不接受所请求页面的 MIME 类型（HTTP 1.1新）。 407 - Proxy Authentication Required 要求进行代理身份验证，类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 - Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）409 - Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 - Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 - Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 - Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。413 – Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 - Request URI Too Long URI太长（HTTP 1.1新）。 415 – 不支持的媒体类型。416 – Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 417 – 执行失败。423 – 锁定的错误。 5xx - 服务器错误12345678910111213141516171819202122232425服务器由于遇到错误而不能完成该请求。500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 500.12 - 应用程序正忙于在 Web 服务器上重新启动。500.13 - Web 服务器太忙。500.15 - 不允许直接请求 Global.asa。500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。500.100 - 内部 ASP 错误。501 - Not Implemented 服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的PUT请求。502 - Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说Web 服务器用作网关或代理服务器时收到了无效响应。502.1 - CGI 应用程序超时。502.2 - CGI 应用程序出错。503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。这个错误代码为IIS 6.0 所专用。504 - Gateway Timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 。505 - HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS TitleTip]]></title>
    <url>%2F2016%2F01%2F19%2FJSTip%2F</url>
    <content type="text"><![CDATA[自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 原生JS TitleTip为了实现对特定的A标签Title的美化，使其可以按照我们想要的样式显示。 方案一： Demo 1&lt;a href=&quot;#&quot; class=&quot;TitleTip&quot; title=&quot;BI Scp&quot; &gt;A标签TitleTip&lt;/a&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;script type=&quot;text/javascript&quot;&gt; var Common = &#123; getItself: function(id) &#123; return &quot;string&quot; == typeof id ? document.getElementById(id) : id; &#125;, getTextSize: function(text) &#123; var span = document.createElement(&quot;span&quot;); var result = &#123;&#125;; result.width = span.offsetWidth; result.height = span.offsetWidth; span.style.visibility = &quot;hidden&quot;; document.body.appendChild(span); if (typeof span.textContent != &quot;undefined&quot;) span.textContent = text; else span.innerText = text; result.width = span.offsetWidth - result.width; result.height = span.offsetHeight - result.height; span.parentNode.removeChild(span); return result; &#125; &#125; var TitleTip = &#123; showTitleTip: function(param, linkObj, e) &#123; var div; if (document.getElementById(&quot;TitleTipDiv&quot;)) &#123; document.body.removeChild(document.getElementById(&quot;TitleTipDiv&quot;)); &#125; div = document.createElement(&quot;div&quot;); div.id = &quot;TitleTipDiv&quot;; // div.style.cssText = &quot;text-align: center; color: #fff; background: rgba(0,0,0,.8); position: absolute; z-index: 100; padding: 5px 15px; font-size: 12px; line-height: 20px; transform: translate(-50%); border-radius: 6px;&quot;; div.innerHTML = linkObj.tip; document.body.appendChild(div); if (param &amp;&amp; param.width) &#123; //如未设置，默认一行显示 if (Common.getTextSize(div.innerHTML).width &lt; param.width) &#123; div.style.maxWidth = param.width + &quot;px&quot;; &#125; else &#123; div.style.width = param.width + &quot;px&quot;; &#125; &#125; //must before set opr to get offsetHeight... div.style.display = &quot;&quot;; ///set TitleTip position // console.log(&quot;a W&quot;+linkObj.offsetWidth); // console.log(&quot;a H&quot;+linkObj.offsetHeight); // console.log(&quot;a X&quot;+linkObj.offsetTop); // console.log(&quot;a Y&quot;+linkObj.offsetLeft); // console.log(&quot;Tip W&quot;+div.offsetWidth); // console.log(&quot;Tip H&quot;+div.offsetHeight); div.style.top = linkObj.offsetTop + linkObj.offsetHeight + 8 + &quot;px&quot;; div.style.left = linkObj.offsetLeft + linkObj.offsetWidth/2 + &quot;px&quot;; ///hide TitleTip after some time if (param &amp;&amp; param.time) &#123; setTimeout(this.hidTitleTip, param.time); &#125; &#125;, hidTitleTip: function() &#123; if (document.getElementById(&quot;TitleTipDiv&quot;)) &#123; document.getElementById(&quot;TitleTipDiv&quot;).style.display = &quot;none&quot;; &#125; &#125;, addTips: function(param) &#123; var linkArr = document.getElementsByTagName(&quot;a&quot;); if (!linkArr) &#123; return false; &#125; for (i = 0; i &lt; linkArr.length; i++) &#123; if (linkArr[i].className == &quot;TitleTip&quot;) &#123; linkArr[i].tip = linkArr[i].title; var tipObj = this; linkArr[i].onmouseover = function(e) &#123; tipObj.showTitleTip(param, this, e); &#125; linkArr[i].onmouseout = tipObj.hidTitleTip; if (param &amp;&amp; param.moveable == true) &#123; //默认不滚动 linkArr[i].onmousemove = function(e) &#123; tipObj.showTitleTip(param, this, e); &#125; &#125; linkArr[i].title = &quot;&quot;; &#125; &#125; &#125; &#125; window.onload = function() &#123; TitleTip.addTips(&#123; width: 200 &#125;); // time:5000, moveable: true &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text历练]]></title>
    <url>%2F2015%2F12%2F21%2FSublimebest%2F</url>
    <content type="text"><![CDATA[自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 编辑器的选择（Editor Choices）Sublime Text是一款跨平台代码编辑器（Code Editor），从最初的Sublime Text 1.0，到现在的Sublime Text 3.0，Sublime Text从一个不知名的编辑器演变到现在几乎是各平台首选的GUI编辑器。官网地址从初学编程到现在，我用过的编辑器有EditPlus、UltraEdit、Notepad++、Vim、TextMate和Sublime Text，如果让我从中推荐，我会毫不犹豫的推荐Vim和Sublime Text，原因有下面几点： 跨平台：Vim和Sublime Text均为跨平台编辑器（在Linux、OS X和Windows下均可使用）。作为一个程序员，切换系统是常有的事情，为了减少重复学习，使用一个跨平台的编辑器是很有必要的。可扩展：Vim和Sublime Text都是可扩展的（Extensible），并包含大量实用插件，我们可以通过安装自己领域的插件来成倍提高工作效率。互补：Vim和Sublime Text分别是命令行环境（CLI）和图形界面环境（GUI）下的最佳选择，同时使用两者会大大提高工作效率。 优点：自动保存代码，代码高亮、语法提示、自动完成且反应快速。少用鼠标，多用键盘。编辑器（Editor） vs 集成开发环境（Integrated Development Environment，下文简称IDE） 我经常看到一些程序员拿编辑器和IDE进行比较，诸如Vim比Eclipse强大或是Visual Studio太慢不如Notepad++好使之类的讨论比比皆是，个人认为这些讨论没有意义，因为编辑器和IDE根本是面向两种不同使用场景的工具：编辑器面向无语义的纯文本，不涉及领域逻辑，因此速度快体积小，适合编写单独的配置文件和动态语言脚本（Shell、Python和Ruby等）。IDE面向有语义的代码，会涉及到大量领域逻辑，因此速度偏慢体积庞大，适合编写静态语言项目（Java、C++和C#等）。我认为应当使用正确的工具去做有价值的事情，并把效率最大化，所以我会用Eclipse编写Java项目，用Vim编写Shell，用Sublime Text编写JavaScript/HTML/Python，用Visual Studio编写C#。前言到此结束，下面进入正题。 界面 1、概况： 从上到下：标题栏Title、菜单栏Menu、标签栏Tab、编辑区Editing Area、控制台Console、状态栏Status Bar。 从做到右：侧边栏（可关闭、文件、文件夹视图）、编辑区（代码编辑）、MiniMap（缩略图）。 菜单栏：各种命令，各种设置。文件File：编辑Edit：选择Selection：查找Find：视图View：转到Goto：工具Tools：项目Project：首选项Preferences：个性化定制。帮助Help： 标签栏：文件名的缩略图，文件编辑未保存，右上角有个小圆点，提示保存。如果未保存关了也不用害怕，自动保存。 状态栏：ASCII编码、Line 6-Column 53（当前行列号）、Tab Size：4（Tab格式等信息）、HTML（当前语言）。 控制台：使用Ctrl+`调出，它既是一个标准的Python REPL，也可以直接对Sublime Text进行配置。 编辑区：这是我们主要的工作区域，ST2支持代码自动缩进，代码折叠功能。 2、常见的功能： 自动完成：自动完成的快捷键是Tab，如果在html文件中，输入cl按下tab，即可自动补全为class=””；加上zencoding后，更是如虎添翼，后面再讲到 多列编辑：按住ctrl点击鼠标，会出现多个闪烁的光标，这时可同时修改多处，或者按住鼠标中键拖拽， 代码注释功能：ctrl+/、ctrl+shift+/分别未行注释和块注释，再按一下就能去掉注释，ST2能够自动识别是html、css还是js文件，给出不同类型的注释。 行操作：ctrl+alt+↑、ctrl+alt+↓向上或者向下交换两行，ctrl+enter，光标后插入空行，ctrl+d选择相似，可以参考后面的快捷键列表。 右键功能：前3个，大家都知道，第4个，show unsaved changes，显示未保存的修改，红色减号表示删去的内容，绿色加号表示新增的内容Open Containing Folder…，打开包含此文件的文件夹，这个很方便找到相关的文件Copy File Path，复制文件路径，方便我们复制路径到浏览器中查看Auto-Format Tags on Selection 格式化选中的文档，方便我们更清晰的查看代码结构，虽然ST2有自动缩进功能，但是当我们粘贴进一段没有格式化过的代码，就需要这个能了，这个功能要安装了Tag这个插件才会出现。 人性化设计：ST2虽然还是beta版中，但是有很多设计细节还是值得称赞的，比如点击一个标签或者括弧，会在起始处显示下划点线，方便看清代码结果，每一层嵌套代码间都有竖线，起到视觉辅助的作用。 设置自定制，数据被保存在Preferences.sublime-settings，Default或User，user可以覆盖default。在配置文件，直接设置配置文件在：preferences－setting user。下面是一些可能有用但我很少用到的功能： 宏（Macro）：Sublime Text支持录制宏，但我在实际工作中并未发现宏有多大用处。 其它平台（Other Platforms）：本文只介绍了Windows平台上Sublime Text的使用，不过Linux和OS X上Sublime Text的使用方式和Windows差别不大，只是在快捷键上有所差异，请参考Windows/Linux快捷键和OS X快捷键。 项目（Projects）：Sublime Text支持简单的项目管理，但我一般只用到文件夹。 Vim模式（Vintage）：Sublime Text自带Vim模式。 构建（Build）：通过配置，Sublime Text可以进行源码构建。 调试（Debug）：通过安装插件，Sublime Text可以对代码进行调试。 快捷键若稍有英文基础，则更建议打开Preferences-&gt;KeyBindings–Default，这里面是详细的快捷键配置。快捷键设置，ST2的快捷键很多，改的时候注意不要覆盖了。因为快捷键众多，所以有下面这种组合快捷键，先按下ctrl+k，松开k，再按下j就可以展开全部代码了。 快捷键列表（Shortcuts Cheatsheet）我把本文出现的Sublime Text按其类型整理在这里，以便查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&gt;### 通用（General） ↑↓←→：上下左右移动光标，注意不是不是KJHL！ Alt：调出菜单### 整理（clear） Tab：缩进：自动完成 Shift+Tab：去除缩进 Ctrl+KT：折叠属性 Ctrl+K0：展开所有### 窗口（Window）### 移动（Move） Ctrl+←/→：进行逐词移动 Ctrl+Shift+←/→进行逐词选择 Ctrl+↑/↓移动当前显示区域 Ctrl+Shift+↑/↓移动当前行 Ctrl+D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl+D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl+K进行跳过，使用Ctrl+U进行回退，使用Esc退出多重### 编辑 Ctrl+Shift+L：将当前选中区域打散### 文件（File） Ctrl+N：在当前窗口创建一个新标签 Ctrl+O：打开文件 Ctrl+Shift+T：打开最近关闭的文件 Ctrl+S：保存 Ctrl+Shift+S：另存为 Ctrl+Shift+N：创建新窗口 Ctrl+Shift+W：关闭窗口 Ctrl+W：关闭当前标签，当窗口内没有标签时会关闭该窗口### 编辑（Edit） Ctrl+Z：撤销 Ctrl+Y：恢复### 取消选择（Undo Selection） Ctrl+U：智能撤销 Ctrl+ Shift+U：智能重做 Ctrl+ Shift+V：粘贴并缩进 Ctrl+K，Ctrl+V：### 行（Line） Ctrl +]：缩进 Ctrl +[：反缩进 Ctrl + Shift + Up：上移一行 Ctrl + Shift + Down：下移一行 Ctrl + Shift + D：复制行(加倍) Ctrl + Shift + K：删除行 Ctrl + J：连接行### 文本（Text） Ctrl+Shift+Enter：在当前行上面增加一行并跳至该行 Ctrl+Alt+Enter：替换所有关键字匹配 Ctrl+Enter：在当前行下面新增一行然后跳至该行 Ctrl+Delete：删除单词前部 Ctrl+Backspace：删除单词后部 Ctrl+K，Ctrl+K：从光标处删除至行尾 Ctrl+K+Backspace：从光标处删除至行首 Ctrl+T：前后调转### 注释（Comment） Ctrl+/：注释（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+Shift：/：块注释(注释已选择内容) Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的### 标签（Tag） Alt+.：闭合当前标签 Ctrl+Shift+A：选择标签(可重复) Ctrl+Shift+W：选择区域被标签包含### （Mark） Ctrl+K， Alt+Space：设置记号 Ctrl+K，Alt+A：选择到记号 Ctrl+K，Alt+W：删除到记号 Ctrl+K，Alt+S：交换(移动)记号 Ctrl+K，Alt+G：移除记号 Ctrl+K，Alt+Y：Yank Ctrl+K，Alt+J：取消所有折叠### 代码折叠（Code Folding） Ctrl+Shift+[：折叠代码 Ctrl+Shift+]：展开代码 （Convert Case） Ctrl+K，Ctrl+U：改为大写 Ctrl+K，Ctrl+L：改为小写### （Wrap） Alt+Q： Ctrl+Space：显示提示 F9：按行排序 Ctrl+F9：按行排序(区分大小写)### 选择（Selection） Ctrl+ Shift+L：分割为多光标(选择多行时) Ctrl+ Alt +Up：向上一行添加光标 Ctrl+ Alt +Down：向下一行添加光标 Escape单光标### 扩展（Expand） Ctrl+A：全选 Ctrl+L：选择整行（按住-继续选择下行） Ctrl+D：选词：（按住-继续选择下个相同的字符串） Ctrl+Shift+Space：快速选择当前作用域（Scope）的内容 Ctrl+Shift+M：快速选择括号间的内容&#123;&#125; Ctrl+Shift+J：快速选择同缩进的内容 Ctrl+Shift+A：选择光标位置父标签对儿### 查找（Find） Ctrl+F：进行标准查找 F3：跳至当前关键字下一个位置 Shift+F3：跳到当前关键字上一个位置 Ctrl +I： Ctrl +H：进行标准替换 Ctrl+Shift+H：替换当前关键字 Ctrl +F3：快速查询 Alt +F3：选中当前关键字出现的所有位置 Ctrl+D：快速查询下一个(多光标) Ctrl+K，Ctrl+D：快速查询跳过下一个(多光标) Ctrl+E：字 Ctrl+Shift+E：字 Ctrl+Shift+F：多文件搜索&amp;替换### 视图（View） Ctrl+K，Ctrl+B：侧边栏开关Side Bar Ctrl+`：调出控制台 F11：切换普通全屏 Shift+F11：切换无干扰全屏 Alt+Shift+2：进行左右分屏 Alt+Shift+5：进行上下左右分屏 Alt+Shift+8：进行上下分屏。 分屏，使用Ctrl+数字键跳转到指定屏，使用Ctrl+Shift+数字键将当前屏移动到指定屏### 组（Group）： Ctrl+K，Ctrl+Up： Ctrl+K，Ctrl+ Shift+ Up： Ctrl+K，Ctrl+Down：### 焦点小组（Focus Group）： Ctrl+K，Ctrl+Right： Ctrl+K，Ctrl+ Left： Ctrl+1：组间切换焦点 Ctrl+ Shift +1：移动文件到组 Syntax语法和文件类型、indentation缩排、Line Endings行尾结束符号 F6：拼写检查 Ctrl + F6：下一个错误 Ctrl+Shift+ F6：上一个错误### 跳转（Goto） Ctrl+P：跳转到指定文件 Ctrl+R：跳转到指定符号 Ctrl+Shift+R： F12： Ctrl+G：跳转到指定行号 Alt+-：跳转到底部 Alt+Shift +-：### 文件开关（Switch File） Ctrl+Pagedown：下一个文件 Ctrl+Pageup：上一个文件 Ctrl+Tab：下一个文件(stack) Ctrl+Shift + Tab：上一个文件(stack) Alt+O： Alt+1：最近打开文件### 滚动（Scroll） Ctrl+K，Ctrl+C：滚动到光标处 Ctrl+Up：向上滚动一行(定光标) Ctrl+Down：向下滚动一行(定光标)### 书签（Boolmarks） Ctrl+F2：设置书签 F2：下一个书签 Shift+F2：上一个书签 Ctrl+Shift+F2：清除书签 Alt+F2：全选书签 Ctrl+M：在起始括号和结尾括号间切换### 工具（Tools） Ctrl+Shift+P：调出命令板（Command Palette） Ctrl +B： Ctrl+Shift+B： Ctrl +Break： F4： Shift+ F4： Ctrl +Q： Ctrl+Shift+Q：### 项目（Project） Ctrl+Alt+P：切换项目 #### 首选项（Preferences） Ctrl+ Keypad Plus： Ctrl+Shift+Keypad Plus： Help（帮助） 总结：多行游标：12345方法一：利用查找替换功能：Ctrl + H方法二（推荐）：Ctrl+D选中另一个，如果有某些不想添加新行的模式则按ctrl+K，ctrl+D跳过这个进入下一个符合条件的模式行。按Alt + F3快捷键，全选所有符合条件的单词。如果要在每行都加入光标，可以先ctrl+A然后ctrl+shift+L即可。如果在某个字符的多行后面加上光标，可以将光标放在这个字符后面，按住shift键，然后右键可以向下拖动产生多个光标。 Goto anything：（模糊匹配）1234Ctrl+P：跳转到指定文件，输入文件名后可以：@ 符号跳转：输入@symbol跳转到symbol符号所在的位置# 关键字跳转：输入#keyword跳转到keyword所在的位置: 行号跳转：输入:12跳转到文件的第12行。 命令快捷执行：12Ctrl+Shift+P：输入set syntax JavaScript进行文件类型更改。输入Minimap进行迷你地图切换。 快速添加新行12Ctrl + Enter可以在当前行下新建一行。 Ctrl + Shift + Enter可以在当前行上面添加一行。 最后购买：Sublime Text2或者3都没关系，3也只是作为2的beta版本，所以还是推荐3吧，支持新版嘛。2和3在使用方法功能上也有差异~你可以去官网下载对应版本，但可能需要输入序列号什么的。访问下载 2.x 版本。或从下载 3.x 版本。 注册码（仅供个人非商业应用）：12345678910111213----- BEGIN LICENSE ------AlexanderSingle User LicenseEA7E-81434551F47F09 4EAB1285 7827EFF0 8B1207DCA76A6EA3 E1A1CA7A DC1F2703 14,897,7848EDC1C82 3F2A58B9 1C0C8B24 67686432281245B3 6233DE5C ADC5C2F9 61FB8A04171B63EF 86BA423F 6AC884FD 3273A7AA5F50A6DB CE7859AE D62D2B37 AEEDD8C2078A8A20 70EEA791 84F48C1E 8ABA7DEB0B3907C0 C9A3523B 0091A045 6F67AED8------ END LICENSE ------ 12345678910111213----- BEGIN LICENSE -----Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523------ END LICENSE ------ 汉化：可以网上找些中文包放进去就行了。Sublime Text 全程指南： 插件：插件的选择：主题：blackboardSideBarEnhancements（侧边栏增强，添加浏览器）Zen CodingadvanceNewfileSyncedSideBartag JsFormat（javascript格式化）ColorPicker （调色盘）GBK to UTF8GBK Encoding Support（GBK中文编码）SublimeLinter（代码错误提示） 总体架构snippets（自定制代码补齐机制） 快捷代码： 跳到行首行尾的快捷键12345[ //跳到行首行尾的快捷键 &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;, &quot;ctrl+h&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;bol&quot;, &quot;extend&quot;: false&#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+k&quot;, &quot;ctrl+e&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;eol&quot;, &quot;extend&quot;: false&#125; &#125;] 先按ctrl+k，然后按ctrl+h（home首字母）光标移动到行首；先按ctrl+k，然后按ctrl+e（end首字母）光标移动到行尾。 设置Setting12//Set Update false&quot;update_check&quot;: false, 延伸阅读（Further Reading）：1、书籍（Books）Mastering Sublime Text：我读过的唯一一本关于Sublime Text的书籍，书中介绍的插件很实用，但对编辑技巧介绍不全。Instant Sublime Text Starter：另外一本关于Sublime Text的书，我没有读过。2、链接（Links） 官方文档： 官方论坛：Stack Overflow的Sublime Text频道： sublimetext sublimetext2 sublimetext3 非官方文档： 甚至比官方文档还要全面！ Package Control： 大量的Sublime Text插件和主题。3、视频（Videos） Getting Started with SublimeText： Sublime Text Pefect Workflow：]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime插件]]></title>
    <url>%2F2015%2F12%2F21%2FSublimePackage%2F</url>
    <content type="text"><![CDATA[自用笔记：本文属于自用笔记，不做详解，仅供参考。在此记录自己已理解并开始遵循的前端代码规范。What How Why 安装有两个办法： 1、直接把插件放到它的安装路径对应文件包packages里面去，不知道在哪的可以直接打开 preferences-&gt;Browse packages，放进去之后软件会自动检测。 2、使用命令方式直接让软件自己下载安装。（使用package control组件）（前提：先安装下面那个package control插件) 按下Ctrl+Shift+P调出命令面板，输入install， 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 下载拷贝：然后把它放到package文件包中。没用过Github的朋友不知道在哪里下载。Download ZIP。然后把它解压，把文件夹放进package文件包，然后它就能检测到包啦！ 代码安装：Ctrl+shift+p、输入install、选择package install 过几秒会弹出另一个框。然后在输入框中输入你想要的插件关键字安装吧！大致就是这样，简单明了。下面介绍其他常用插件，安装方式同理！ 常用插件： package control（包裹组件） 通过快捷键 ctrl+` 或者 View &gt; Show Console 菜单打开控制台，然后粘贴对应的版本代码进去，然后回车让它安装。 适用于 Sublime Text 3： 1import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 适用于 Sublime Text 2： 1import urllib2,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) 当然了，有些时候这样你安装不进去的，就只能自个去下载安装包放到package文件里边去了（就是上边我说的那个文件夹)如果在Preferences → Package Settings 中看到 Package Control 这一项，说明安装成功。 插件整理 代码整理： Tag（代码格式化） 全选Ctrl+A，Ctrl+Alt+F HTMLBeautify（） 格式化HTML。 HTML/CSS/JS Prettify（代码格式化） 能够格式化css html和js。 注意：格式化的文件路径中不能有中文，不然会报找不到node的错误（windows下）。 YUI Compressor（压缩JS和CSS文件） PHPTidy（整理与排版PHP代码） JsFormat（javascript格式化） 格式化js代码，这个插件很有用，我们有时在网上看到某些效果，想查看是怎么实现的，但是代码被压缩过，很难阅读，不用怕，用ST2打开，按下ctrl+alt+5（这是我设置的快捷键），即可让代码还原，莫非是武林中失传已久的“还我靓靓拳”。 注释： DocBlockr（代码自动注释生成） HtmlTidy（清理与排版你的HTML代码） AutoPEP8（） 格式化Python代码。 Alignment安装案例 Alignment（代码补齐）补齐就是补齐~就像这样 代码简写： SublimeCodeIntel（代码提示） 自动提示我们，可能要输入HTML代码内容 snippets（自定制代码补齐机制） 自定制代码补齐机制， Emmet（Zen Coding 代码自动补齐） 通过简单的命令直接生成一大段代码！一个字又快又准，安装好插件后，使用Ctrl＋Alt＋Enter呼出ZenCoding。我们可以用 div#content&gt;ul&gt;li3&gt;a [href=”javascript:void(0);”]{Links$} 这样短短的一句话，生成下面一段代码：技巧：前端必备，快速开发HTML/CSS 输入 div.wrapper&gt;div.header+div.main+div.footer 按下Tab，立刻变成 或者按下ctrl+alt+enter，激发zencoding控制台，可看到整个动态的过程。 高亮显示： BracketHighlighter BracketHighlighter高亮显示匹配的括号、引号和标签，BracketHighlighter这个插件能在左侧高亮显示匹配的括号、引号和标签，能匹配的 [] , () , {} , “” , ‘’ , 等甚至是自定义的标签，当看到密密麻麻的代码分不清标签之间包容嵌套的关系时，这款插件就能很好地帮你理清楚代码结构，快速定位括号，引号和标签内的范围。 TrailingSpacer（高亮显示多余的空格和Tab） 颜色： ColorPicker （调色盘） 在编辑CSS样式的时候，ColorPicker可以让sublime text 内置一个调色盘，调好颜色，点击OK就会在光标处生成十六进制颜色代码。 CSS： CSScomb（CSS属性排序） CSS3_Syntax（css语法高亮） 对css语法高亮的支持，view-syntax-css3选中css3就能使用css3高亮了。必须每条属性都加上分号，并且属性必须小写，不然不会高亮，有点鸡肋啊。 Prefixr（自动加-webkit前缀） 写 CSS可自动添加 -webkit 等私有词缀，Ctrl+Alt+X触发。 Autoprefixer（自动加前缀） 可以给css自动加前缀功能 Goto-CSS-Declaration（CSS文件跳转） 跳转到css文件该class的声明处，方便修改查看，如图下所示，注意对应的css文件要同时打开才行。 编码： GBK Encoding Support（GBK中文编码） 这个插件还是非常有用的，因为sublime 本身 不支持gbk编码，在utf8如此流行的今天，我们整站还是gbk编码，o(︶︿︶)o 唉，所以全靠这个插件了。 GBK to UTF8（编码转换） 将文件编码从GBK转换成UTF8，菜单 – File里面找。 文档管理： Nettus+ fetch （管理一些开源框架） 配置文件修改，Ctrl+Shift+P输入Fetch Manage，配置文档。通过输入fetch file，搜索框架名进行导入。 SideBarEnhancements（侧边栏增强） SyncedSideBar（侧边栏打开文件定位） 支持当前文件在左侧面板中定位，不错。 Hex-to-HSL-Color Hex（颜色模式转HSL颜色模式） advanceNewfile（面板随意添加文件） 按Ctrl+Alt+N，下方输入A\B\test.css就好了，test.css这个文件出现在某个文件夹。 SublimeTmpl （自定义新建文件） 默认已经添加了html、css、js等常见类型的面板，按ctrl+alt+h/ctrl+alt+c/ctrl+alt+j可新建这 3钟类型的文件，快捷键在这里\Packages\SublimeTmpl\Default (Windows).sublime-keymap, 模板文件在这里\Packages\SublimeTmpl\templates，可修改。 比如下边简单的html文件 DocBlockr（代码建立文档） DocBlockr 可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。 GotoRecent（历史文档记录） 打开最近的文件，系统有这个功能，但只能看最近8个，有点不爽，按ctrl+e，选择即可。 语法识别： jQuery（jQuery语法识别） 支持jquery的只能语法提示，很赞。 JavaScriptNext - ES6 Syntax（ES6语法识别） 提供ES6的语法支持。 WordPress（WordPress的函数） 集成一些WordPress的函数，对于像我这种经常要写WP模版和插件的人特别有用 Vintage（Vim模拟） 如果你习惯使用vim，那么可以安装这个插件，这个插件可以让sublime像vim一样。 LESS（LESS语法识别） 这是一个非常棒的插件，可以让sublime支持less的语法高亮和语法提示，对于搞less的同学灰常重要，不过多解释。 SCSS（SCSS语法识别） 支持scss的语法高亮，里面附带了好多CSS Snippet，无论现用或者改造成，都可节省不少时间。 Liquid（Liquid语法识别） 提供Liquid语法支持，如果你也写博客的话不妨试试。 Smarty（Smarty语法识别） 提供smarty语法的支持。Smarty插件默认的分隔符是{}，如果你使用的分隔符不同可以更改插件目录的Smarty.tmPreferences文件，找到其中的SMARTY_LDELIM和SMARTY_RDELIM，修改为你的分隔符即可。 文件传输： SFTP（编辑 FTP 或 SFTP 服务器上的文件） Package Syncing 最后推荐一个同步插件，这个插件可以在不同的机器同步配置信息和插件，非常方便，但鉴于国内的墙太高，我都是直接把插件给手动备份了，然后直接拖进去，或者直接去github上下载对应的包。 其他： Gits（集成 GitHub） Clipboard-history（粘贴板历史记录） 可以保存粘贴的历史，很赞的功能，再也不用担心历史丢失了。ctrl+alt+v可打开历史面板，上下选择即可，安装后会和默认的ctrl+shift+v（粘贴缩进）冲突，干掉这个快捷键。 lint（语法校验）： SublimeLinter（代码错误提示） 总体架构 Jslint编程风格 Sub Tradsim（中文繁字体和简体字转换） Terminal 可以sublime中，打开命令行，非常方便哦。 AllAutocomplete 自动完成插件，可在全部打开的文件中，自动完成。 HexViewer 提供十六进制文件查看功能。 MultiEditUtils 扩展多行编辑的功能。 IMESupport（输入框不更随着光标） 主题（Themes）Sublime Text有大量第三方主题： 1、Facebook Material Theme 2、Soda]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
</search>
